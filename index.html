<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite Status & Community Hub</title>
    
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- Emoji Picker Library -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>

    <style>
        /* Custom styles for a modern, gaming-inspired look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0F172A; /* Darker blue */
            color: #E5E7EB;
            overflow: hidden;
        }

        /* Starry background effect */
        .stars {
            background: #0F172A url(data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjEwMHB4IiBoZWlnaHQ9IjEwMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSIyMyIgaWQ9InN0YXIxIiBjeT0iMjMiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iMzMiIGlkPSJzdGFyMiIgY3k9IjMzIiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9IjQ1IiBpZD0ic3RhcjMiIGN5PSI0NSIgcj0iMC41Ii8+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSI1MiIgaWQ9InN0YXI0IiBjeT0iNTIiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iODciIGlkPSJzdGFyNSIgY3k9Ijg3IiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9Ijc1IiBpZD0ic3RhcjYiIGN5PSI3NSIgcj0iMC41Ii8+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSI5MiIgaWQ9InN0YXI3IiBjeT0iOTEiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iMTIiIGlkPSJzdGFyOCIgY3k9IjEyIiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9IjQwIiBpZD0ic3RhcjkiIGN5PSI4IiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9Ijg4IiBpZD0ic3RhcjEwIiBjeT0iMyIgcj0iMC41Ii8+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSI5OCIgaWQ9InN0YXIxMSIgY3k9IjUiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iOTMiIGlkPSJzdGFyMTIiIGN5PSI5MyIgcj0iMC41Ii8+PC9zdmc+) repeat;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: -1;
            animation: move-stars 200s linear infinite;
        }

        @keyframes move-stars {
            from { background-position: 0 0; }
            to { background-position: -10000px 5000px; }
        }

        /* Glassmorphism effect for modals and cards */
        .glass-card {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }

        /* Animation for modals */
        .modal-enter { animation: fadeIn 0.3s ease-out forwards; }
        .modal-leave { animation: fadeOut 0.3s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeOut { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.95); } }

        /* Custom button styles */
        .btn-primary { @apply bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg transform transition-all duration-300; }
        .btn-primary:hover { @apply bg-blue-500 scale-105 shadow-blue-500/50; }
        .btn-secondary { @apply bg-slate-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transform transition-all duration-300; }
        .btn-secondary:hover { @apply bg-slate-600 scale-105; }
        
        /* Loading spinner */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3B82F6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Recording Indicator */
        .recording-indicator {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
    </style>
</head>
<body class="w-full h-screen">

    <div class="stars"></div>

    <!-- Main Application Container -->
    <div id="app-container" class="w-full h-full flex flex-col">
        
        <!-- Header -->
        <header class="w-full p-4 flex justify-between items-center">
            <h1 id="header-title" class="text-xl font-bold text-white">Fortnite Status</h1>
            <div id="header-actions" class="flex items-center gap-4">
                <!-- Logged in actions will be injected here -->
            </div>
        </header>

        <!-- Main Content Area -->
        <main id="main-content" class="flex-grow flex flex-col p-4 overflow-y-auto">
            <!-- Content is rendered dynamically by JS -->
        </main>
    </div>

    <!-- Modals -->
    <div id="modal-backdrop" class="hidden fixed inset-0 bg-black/50 z-40"></div>
    
    <!-- Auth Modal -->
    <div id="auth-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 modal-enter">
        <div class="glass-card w-full max-w-md p-8 shadow-2xl">
            <div class="flex justify-between items-center mb-6">
                <h2 id="auth-title" class="text-2xl font-bold text-white">Anmelden</h2>
                <button id="close-auth-modal" class="text-gray-400 hover:text-white"><i data-lucide="x"></i></button>
            </div>
            <div id="auth-content"></div>
        </div>
    </div>

    <!-- Chats & Friends Modal -->
    <div id="chats-friends-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 modal-enter">
        <div class="glass-card w-full max-w-2xl h-[70vh] flex flex-col p-6 shadow-2xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-white">Chats & Freunde</h2>
                <button id="close-chats-friends-modal" class="text-gray-400 hover:text-white"><i data-lucide="x"></i></button>
            </div>
            <div class="border-b border-slate-700">
                <nav class="flex space-x-4">
                    <button data-tab="chats" class="tab-btn py-2 px-4 text-white border-b-2 border-blue-500 font-semibold">Chats</button>
                    <button data-tab="friends" class="tab-btn py-2 px-4 text-gray-400 border-b-2 border-transparent hover:border-gray-500">Freunde</button>
                </nav>
            </div>
            <div id="chats-friends-content" class="overflow-y-auto flex-grow mt-4"></div>
        </div>
    </div>
    
    <!-- Other Modals (Notes, Settings, Profile Pic, Admin, Video Player) will use this generic structure -->
    <div id="generic-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 modal-enter">
        <div class="glass-card w-full max-w-4xl h-auto max-h-[90vh] flex flex-col p-6 shadow-2xl">
            <div class="flex justify-between items-center mb-4 pb-4 border-b border-slate-700">
                <h2 id="generic-modal-title" class="text-2xl font-bold text-white flex-grow"></h2>
                <div id="generic-modal-header-actions" class="flex items-center gap-2"></div>
                <button id="close-generic-modal" class="text-gray-400 hover:text-white ml-4"><i data-lucide="x"></i></button>
            </div>
            <div id="generic-modal-content" class="overflow-y-auto flex-grow"></div>
            <div id="generic-modal-footer" class="mt-4 pt-4 border-t border-slate-700"></div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-black/70 z-[100] flex flex-col items-center justify-center">
        <div class="loader"></div>
        <p id="loading-text" class="text-white mt-4 text-lg">Lade...</p>
    </div>

    <!-- Custom Toast Notification -->
    <div id="toast" class="hidden fixed bottom-5 right-5 glass-card p-4 rounded-lg shadow-lg z-[101] flex items-center gap-3">
        <i id="toast-icon" data-lucide="check-circle" class="text-green-400"></i>
        <p id="toast-message"></p>
    </div>

    <!-- Message Context Menu -->
    <div id="message-context-menu" class="hidden absolute z-[60] glass-card p-1 rounded-lg">
        <button id="delete-context-btn" class="flex items-center gap-2 text-sm text-red-400 hover:bg-red-500/20 px-3 py-1 rounded-md w-full">
            <i data-lucide="trash-2" class="w-4 h-4"></i>
            <span>Löschen</span>
        </button>
        <button id="report-context-btn" class="flex items-center gap-2 text-sm text-yellow-400 hover:bg-yellow-500/20 px-3 py-1 rounded-md w-full">
            <i data-lucide="flag" class="w-4 h-4"></i>
            <span>Melden</span>
        </button>
    </div>

    <!-- Emoji & GIF Picker Popover -->
    <div id="chat-picker-popover" class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-[60] glass-card p-2 rounded-lg w-full max-w-sm">
        <!-- Content will be injected by JS -->
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getDatabase, ref as dbRef, onValue, set, onDisconnect, serverTimestamp as rtdbServerTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
        import { getStorage, ref as storageRef, getDownloadURL, uploadBytesResumable, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updateProfile, deleteUser, sendEmailVerification, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, getDocs, collection, writeBatch, serverTimestamp, query, where, onSnapshot, updateDoc, arrayUnion, arrayRemove, addDoc, orderBy, deleteDoc, increment, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyB3Fqc0P3TmSb80GupZrXONZiejStgk6TE",
            authDomain: "social-media-1711a.firebaseapp.com",
            projectId: "social-media-1711a",
            storageBucket: "social-media-1711a.appspot.com",
            messagingSenderId: "228987477362",
            appId: "1:228987477362:web:0aa477a08b4d14572e51eb",
            measurementId: "G-SNQC7S4CJB",
            databaseURL: "https://social-media-1711a-default-rtdb.europe-west1.firebasedatabase.app"
        };

        // --- APP INITIALIZATION ---
        let app, auth, db, rtdb, storage;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            rtdb = getDatabase(app);
            storage = getStorage(app);
        } catch (e) {
            document.getElementById('main-content').innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold text-red-500">Fehler bei der Firebase-Initialisierung!</h2><p class="mt-2 text-gray-400">Fehler: ${e.message}</p></div>`;
            console.error("Firebase initialization failed:", e);
        }
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'fortnite-social-app';

        // --- GIPHY API KEY ---
        const GIPHY_API_KEY = 'BAE8RypYNwugJzhT1oMmqbWMHujifiuf';


        // --- DOM ELEMENT REFERENCES ---
        const mainContent = document.getElementById('main-content');
        const headerTitle = document.getElementById('header-title');
        const headerActions = document.getElementById('header-actions');
        const loadingOverlay = document.getElementById('loading-overlay');
        const modalBackdrop = document.getElementById('modal-backdrop');
        const authModal = document.getElementById('auth-modal');
        const chatsFriendsModal = document.getElementById('chats-friends-modal');
        const genericModal = document.getElementById('generic-modal');
        const pickerPopover = document.getElementById('chat-picker-popover');
        
        // --- GLOBAL STATE ---
        let currentUser = null;
        let currentUserProfile = null;
        let unsubscribeUserListener = null;
        let isRegistering = false;
        let typingTimeout = null;
        let unsubscribeChatListener = null;
        let unsubscribeTypingListener = null;
        let longPressTimer = null;
        let activeChatId = null;
        let activeChatType = null;
        let notificationSound;
        let previousUnreadCount = 0;
        let activePicker = null; // 'emoji' or 'gif'
        let mediaRecorder = null;
        let isRecording = false;
        let audioChunks = [];
        let inactivityTimer = null;

        // --- HELPER & MODAL FUNCTIONS ---
        const showLoader = (text = 'Lade...') => {
            document.getElementById('loading-text').textContent = text;
            loadingOverlay.classList.remove('hidden');
        };
        const hideLoader = () => {
            loadingOverlay.classList.add('hidden');
        };
        const showToast = (message, type = 'success') => {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            const toastIcon = document.getElementById('toast-icon');
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            if (type === 'success') {
                toastIcon.setAttribute('data-lucide', 'check-circle');
                toastIcon.setAttribute('class', 'text-green-400');
            } else if (type === 'error') {
                toastIcon.setAttribute('data-lucide', 'alert-circle');
                toastIcon.setAttribute('class', 'text-red-400');
            } else {
                toastIcon.setAttribute('data-lucide', 'info');
                toastIcon.setAttribute('class', 'text-blue-400');
            }
            lucide.createIcons();
            setTimeout(() => { toast.classList.add('hidden') }, 3000);
        };
        const openModal = (modalElement) => {
            modalBackdrop.classList.remove('hidden');
            modalElement.classList.remove('hidden', 'modal-leave');
            modalElement.classList.add('modal-enter');
        };
        const closeModal = (modalElement) => {
            modalElement.classList.remove('modal-enter');
            modalElement.classList.add('modal-leave');
            setTimeout(() => {
                modalElement.classList.add('hidden');
                if (!document.querySelector('.modal-enter:not(.hidden)')) {
                    modalBackdrop.classList.add('hidden');
                }
            }, 300);
        };
        const showConfirmationModal = (message, onConfirm) => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = 'Bestätigung';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `<p class="text-gray-300">${message}</p>`;
            modalFooter.innerHTML = `
                <div class="flex justify-end gap-4">
                    <button id="confirm-cancel-btn" class="btn-secondary">Abbrechen</button>
                    <button id="confirm-ok-btn" class="btn-primary bg-red-600 hover:bg-red-500">Bestätigen</button>
                </div>
            `;
            openModal(genericModal);
            document.getElementById('confirm-ok-btn').onclick = () => { onConfirm(); closeModal(genericModal); };
            document.getElementById('confirm-cancel-btn').onclick = () => closeModal(genericModal);
        };

        const linkify = (inputText) => {
            if (!inputText) return '';
            let replacedText;

            // URLs starting with http://, https://, or ftp://
            const urlPattern = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
            replacedText = inputText.replace(urlPattern, '<a href="$1" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">$1</a>');

            // URLs starting with "www." (without // before it)
            const wwwPattern = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
            replacedText = replacedText.replace(wwwPattern, '$1<a href="http://$2" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">$2</a>');

            return replacedText;
        };

        // --- ADMIN & REPORTING FUNCTIONS ---
        const showReportModal = (contentId, contentType, context = {}) => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            if (contentType === 'user') {
                 modalTitle.textContent = `Nutzer "${context.userName}" melden`;
            } else {
                 modalTitle.textContent = 'Inhalt melden';
            }
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <label for="report-reason" class="block text-sm font-medium text-gray-300 mb-1">Grund für die Meldung</label>
                        <select id="report-reason" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg">
                            <option>Spam oder irreführend</option>
                            <option>Hassrede oder Belästigung</option>
                            <option>Gewalttätige oder abstoßende Inhalte</option>
                            <option>Nacktheit oder sexuelle Inhalte</option>
                            <option>Sonstiges</option>
                        </select>
                    </div>
                    <div>
                        <label for="report-details" class="block text-sm font-medium text-gray-300 mb-1">Zusätzliche Details (optional)</label>
                        <textarea id="report-details" rows="4" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg" placeholder="Bitte gib mehr Informationen an..."></textarea>
                    </div>
                </div>
            `;
            modalFooter.innerHTML = `<button id="submit-report-btn" class="btn-primary bg-red-600 hover:bg-red-500 w-full">Meldung abschicken</button>`;
            openModal(genericModal);

            document.getElementById('submit-report-btn').addEventListener('click', () => {
                const reason = document.getElementById('report-reason').value;
                const details = document.getElementById('report-details').value;
                handleReportSubmit(contentId, contentType, reason, details, context);
            });
        };

        const handleReportSubmit = async (contentId, contentType, reason, details, context) => {
            if (!currentUser) {
                showToast("Du musst angemeldet sein, um Inhalte zu melden.", "error");
                return;
            }
            showLoader("Meldung wird gesendet...");
            try {
                await addDoc(collection(db, 'reports'), {
                    reporterId: currentUser.uid,
                    reporterName: currentUserProfile.displayName,
                    contentId,
                    contentType,
                    reason,
                    details,
                    context, // z.B. { chatId, chatType, senderId, userName }
                    status: 'open',
                    timestamp: serverTimestamp()
                });
                showToast("Meldung erfolgreich übermittelt. Vielen Dank!", "success");
                closeModal(genericModal);
            } catch (error) {
                console.error("Error submitting report:", error);
                showToast("Fehler beim Senden der Meldung.", "error");
            } finally {
                hideLoader();
            }
        };
        
        const renderAdminUsers = async () => {
            const adminContentArea = document.getElementById('admin-content-area');
            if (!adminContentArea) return;
            adminContentArea.innerHTML = '<div class="loader"></div>';

            try {
                const usersRef = collection(db, "users");
                const querySnapshot = await getDocs(usersRef);
                let userCardsHtml = '';
                querySnapshot.forEach(doc => {
                    const user = {id: doc.id, ...doc.data()};
                    if (user.id === currentUser.uid) return;
                    
                    const crownIcon = user.role === 'founder' || user.role === 'admin' ? `<i data-lucide="crown" class="w-5 h-5 text-yellow-400"></i>` : '';
                    let adminDateHtml = '';
                    if (user.role === 'admin' && user.promotedToAdminAt) {
                        const date = user.promotedToAdminAt.toDate().toLocaleDateString('de-DE');
                        adminDateHtml = `<p class="text-xs text-gray-400 mt-1">Admin seit: ${date}</p>`;
                    }
                    
                    let adminButtonHtml = '';
                    if (user.role === 'founder') {
                        adminButtonHtml = `<button class="btn-secondary text-sm flex-grow opacity-50 cursor-not-allowed" disabled>Gründer</button>`;
                    } else {
                        adminButtonHtml = `<button data-id="${user.id}" data-role="${user.role}" class="toggle-admin-btn btn-secondary text-sm flex-grow ${currentUserProfile.role !== 'founder' ? 'opacity-50 cursor-not-allowed' : ''}" ${currentUserProfile.role !== 'founder' ? 'disabled' : ''}>${user.role === 'admin' ? 'Admin entfernen' : 'Admin geben'}</button>`;
                    }

                    let banButtonHtml = '';
                    if (user.role === 'founder') {
                        banButtonHtml = `<button class="bg-slate-800 text-gray-500 font-bold py-2 px-4 rounded-lg text-sm flex-grow cursor-not-allowed" disabled>Unantastbar</button>`;
                    } else {
                        banButtonHtml = `<button data-id="${user.id}" data-banned="${user.banned}" class="toggle-ban-btn ${user.banned ? 'bg-green-600 hover:bg-green-500' : 'bg-red-600 hover:bg-red-500'} text-white font-bold py-2 px-4 rounded-lg text-sm flex-grow">${user.banned ? 'Entsperren' : 'Sperren'}</button>`;
                    }

                    let verifyButtonHtml = '';
                    if (!user.emailVerified && !user.isManuallyVerified && (currentUserProfile.role === 'admin' || currentUserProfile.role === 'founder')) {
                        verifyButtonHtml = `<button data-id="${user.id}" class="manual-verify-btn btn-secondary bg-green-600 hover:bg-green-500 text-sm flex-grow">Verifizieren</button>`;
                    }


                    userCardsHtml += `
                        <div class="glass-card p-4 rounded-lg mb-4">
                            <div class="flex justify-between items-start">
                                <div class="flex items-center gap-3">
                                    <img src="${user.photoURL || `https://placehold.co/48x48/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-12 h-12 rounded-full object-cover">
                                    <div>
                                        <p class="font-bold text-lg flex items-center gap-2">${user.displayName} ${crownIcon}</p>
                                        <p class="text-sm text-gray-400">${user.email}</p>
                                        ${adminDateHtml}
                                    </div>
                                </div>
                                <div class="text-right">
                                    <p class="text-sm text-gray-400">Bans: ${user.banCount || 0}</p>
                                </div>
                            </div>
                            <div class="mt-4 pt-4 border-t border-slate-700 flex gap-2">
                                ${adminButtonHtml}
                                ${banButtonHtml}
                                ${verifyButtonHtml}
                            </div>
                        </div>
                    `;
                });
                adminContentArea.innerHTML = `<div class="space-y-4">${userCardsHtml}</div>`;
                lucide.createIcons();
                adminContentArea.querySelectorAll('.toggle-admin-btn').forEach(btn => { btn.addEventListener('click', () => toggleAdminRole(btn.dataset.id, btn.dataset.role)); });
                adminContentArea.querySelectorAll('.toggle-ban-btn').forEach(btn => { btn.addEventListener('click', () => toggleBanStatus(btn.dataset.id, btn.dataset.banned === 'true')); });
                adminContentArea.querySelectorAll('.manual-verify-btn').forEach(btn => { btn.addEventListener('click', () => handleManualVerify(btn.dataset.id)); });
            } catch (error) {
                console.error("Error fetching users for admin panel:", error);
                adminContentArea.innerHTML = `<div class="text-center p-4"><p class="text-red-400">Fehler beim Laden der Benutzerliste.</p><p class="text-gray-400 mt-2 text-sm">Dies liegt wahrscheinlich an den Firestore-Sicherheitsregeln. Administratoren benötigen eine "list"-Berechtigung für die "users"-Sammlung, um alle Benutzer anzuzeigen.</p></div>`;
            }
        };

        const handleManualVerify = async (userId) => {
            showConfirmationModal('Möchtest du diesen Nutzer wirklich manuell verifizieren?', async () => {
                showLoader('Verifiziere Nutzer...');
                try {
                    const userRef = doc(db, 'users', userId);
                    await updateDoc(userRef, { isManuallyVerified: true });
                    showToast('Nutzer erfolgreich verifiziert.', 'success');
                    renderAdminUsers(); // Refresh the admin panel
                } catch (error) {
                    console.error("Error manually verifying user:", error);
                    showToast('Fehler bei der manuellen Verifizierung.', 'error');
                } finally {
                    hideLoader();
                }
            });
        };

        const renderAdminReports = async () => {
            const adminContentArea = document.getElementById('admin-content-area');
            if (!adminContentArea) return;
            adminContentArea.innerHTML = '<div class="loader"></div>';

            try {
                const reportsQuery = query(collection(db, "reports"), where('status', '==', 'open'));
                const snapshot = await getDocs(reportsQuery);
                
                if (snapshot.empty) {
                    adminContentArea.innerHTML = `<p class="text-center text-gray-400">Keine offenen Meldungen.</p>`;
                    return;
                }

                const reports = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                reports.sort((a, b) => {
                    const timeA = a.timestamp?.toMillis() || 0;
                    const timeB = b.timestamp?.toMillis() || 0;
                    return timeB - timeA;
                });

                let reportsHtml = '';
                for (const report of reports) {
                    let reportedContentInfo = `Gemeldeter Inhalt: ${report.contentType}`;
                    if(report.contentType === 'user' && report.context?.userName) {
                        reportedContentInfo = `Gemeldeter Nutzer: <strong>${report.context.userName}</strong>`;
                    } else {
                        reportedContentInfo = `Gemeldeter Inhalt: ${report.contentType} (${report.contentId.substring(0, 8)}...)`;
                    }

                    reportsHtml += `
                        <div class="glass-card p-4 rounded-lg mb-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="font-bold text-yellow-400">${report.reason}</p>
                                    <p class="text-sm text-gray-300">${reportedContentInfo}</p>
                                    <p class="text-sm text-gray-400">Gemeldet von: ${report.reporterName}</p>
                                    <p class="text-sm text-gray-500 mt-2">${report.details || 'Keine weiteren Details.'}</p>
                                </div>
                                <span class="text-xs text-gray-500">${report.timestamp.toDate().toLocaleString('de-DE')}</span>
                            </div>
                            <div class="mt-4 pt-4 border-t border-slate-700 flex gap-2">
                                <button data-report-id="${report.id}" class="resolve-report-btn btn-secondary bg-green-600 hover:bg-green-500 text-sm">Als erledigt markieren</button>
                            </div>
                        </div>
                    `;
                }
                adminContentArea.innerHTML = `<div class="space-y-4">${reportsHtml}</div>`;
                adminContentArea.querySelectorAll('.resolve-report-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        showConfirmationModal('Möchtest du diese Meldung wirklich als erledigt markieren?', async () => {
                            await updateDoc(doc(db, 'reports', btn.dataset.reportId), { status: 'resolved' });
                            showToast('Meldung als erledigt markiert.', 'success');
                            renderAdminReports();
                        });
                    });
                });

            } catch (error) {
                console.error("Error fetching reports:", error);
                adminContentArea.innerHTML = `<div class="text-center p-4"><p class="text-red-400">Fehler beim Laden der Meldungen.</p><p class="text-gray-400 mt-2 text-sm">Dies liegt wahrscheinlich an den Firestore-Sicherheitsregeln. Administratoren benötigen eine "list"-Berechtigung für die "reports"-Sammlung, um alle Meldungen anzuzeigen.</p></div>`;
            }
        };
        
        const showAdminPanel = async () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');

            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Admin Panel';
            document.getElementById('generic-modal-header-actions').innerHTML = `
                <div class="border-b border-slate-700">
                    <nav class="flex space-x-1">
                        <button data-tab="users" class="admin-tab-btn py-2 px-3 text-white border-b-2 border-blue-500 font-semibold text-sm">Benutzer</button>
                        <button data-tab="reports" class="admin-tab-btn py-2 px-3 text-gray-400 border-b-2 border-transparent hover:border-gray-500 text-sm">Meldungen</button>
                    </nav>
                </div>
            `;
            modalContent.innerHTML = '<div id="admin-content-area" class="mt-4"><div class="loader"></div></div>';
            modalFooter.innerHTML = '';
            openModal(genericModal);
            
            document.querySelectorAll('.admin-tab-btn').forEach(btn => {
                btn.onclick = (e) => {
                    document.querySelectorAll('.admin-tab-btn').forEach(b => { b.classList.remove('text-white', 'border-blue-500'); b.classList.add('text-gray-400', 'border-transparent'); });
                    e.currentTarget.classList.add('text-white', 'border-blue-500');
                    e.currentTarget.classList.remove('text-gray-400', 'border-transparent');
                    if (e.currentTarget.dataset.tab === 'users') {
                        renderAdminUsers();
                    } else if (e.currentTarget.dataset.tab === 'reports') {
                        renderAdminReports();
                    }
                };
            });

            renderAdminUsers(); // Standardmäßig Benutzer anzeigen
        };

        const toggleAdminRole = async (userId, currentRole) => {
            if (currentUserProfile.role !== 'founder') { showToast('Nur der Gründer kann Rollen ändern.', 'error'); return; }
            const newRole = currentRole === 'admin' ? 'user' : 'admin';
            const updateData = { role: newRole };
            if (newRole === 'admin') {
                updateData.promotedToAdminAt = serverTimestamp();
            } else {
                updateData.promotedToAdminAt = deleteField();
            }
            
            showLoader('Rolle wird aktualisiert...');
            try {
                const userRef = doc(db, `users/${userId}`);
                await updateDoc(userRef, updateData);
                showToast('Benutzerrolle aktualisiert.', 'success');
                renderAdminUsers();
            } catch (error) {
                showToast(`Fehler: ${error.message}`, 'error');
            } finally {
                hideLoader();
            }
        };

        const toggleBanStatus = async (userId, isCurrentlyBanned) => {
            const userToModifyRef = doc(db, "users", userId);
            const userToModifySnap = await getDoc(userToModifyRef);
            if (userToModifySnap.exists() && userToModifySnap.data().role === 'founder') {
                showToast("Der Gründer kann nicht gesperrt werden.", "error");
                return;
            }

            if (isCurrentlyBanned) {
                showLoader('Benutzer wird entsperrt...');
                try {
                    await updateDoc(userToModifyRef, { banned: false, bannedBy: null });
                    showToast('Benutzer wurde entsperrt.', 'success');
                    renderAdminUsers();
                } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } finally { hideLoader(); }
            } else {
                showLoader('Benutzer wird gesperrt...');
                try {
                    await updateDoc(userToModifyRef, { 
                        banned: true,
                        bannedBy: currentUser.uid,
                        banCount: increment(1)
                    });
                    showToast('Benutzer wurde gesperrt.', 'success');
                    renderAdminUsers();
                } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } finally { hideLoader(); }
            }
        };

        // --- AUTHENTICATION LOGIC ---
        const handleLogout = async () => {
            if (currentUser) {
                const userStatusFirestoreRef = doc(db, 'users', currentUser.uid);
                await updateDoc(userStatusFirestoreRef, {
                    presence: 'offline',
                    last_seen: serverTimestamp(),
                });
                const userStatusDatabaseRef = dbRef(rtdb, '/status/' + currentUser.uid);
                set(userStatusDatabaseRef, { state: 'offline', last_changed: rtdbServerTimestamp() });
            }
            showLoader('Abmelden...');
            try {
                await signOut(auth);
                showToast('Erfolgreich abgemeldet.', 'info');
            } catch (error) {
                showToast(`Fehler beim Abmelden: ${error.message}`, 'error');
            } finally {
                hideLoader();
            }
        };

        const setupPresenceSystem = (uid) => {
            const userStatusDatabaseRef = dbRef(rtdb, '/status/' + uid);
            const userStatusFirestoreRef = doc(db, '/users/' + uid);

            const isOfflineForDatabase = {
                state: 'offline',
                last_changed: rtdbServerTimestamp(),
            };
            const isOnlineForDatabase = {
                state: 'online',
                last_changed: rtdbServerTimestamp(),
            };
             const isAwayForDatabase = {
                state: 'away',
                last_changed: rtdbServerTimestamp(),
            };

            const isOfflineForFirestore = {
                presence: 'offline',
                last_seen: serverTimestamp(),
            };
            const isOnlineForFirestore = {
                presence: 'online',
                last_seen: serverTimestamp(),
            };
             const isAwayForFirestore = {
                presence: 'away',
                last_seen: serverTimestamp(),
            };

            onValue(dbRef(rtdb, '.info/connected'), (snapshot) => {
                if (snapshot.val() === false) {
                    updateDoc(userStatusFirestoreRef, isOfflineForFirestore);
                    return;
                }

                onDisconnect(userStatusDatabaseRef).set(isOfflineForDatabase).then(() => {
                    updateDoc(userStatusFirestoreRef, isOfflineForFirestore);
                });

                set(userStatusDatabaseRef, isOnlineForDatabase);
                updateDoc(userStatusFirestoreRef, isOnlineForFirestore);

                const resetTimer = () => {
                    if (inactivityTimer) clearTimeout(inactivityTimer);
                    
                    const currentStatusRef = dbRef(rtdb, '/status/' + uid + '/state');
                    onValue(currentStatusRef, (snap) => {
                        if (snap.val() === 'away') {
                             set(userStatusDatabaseRef, isOnlineForDatabase);
                             updateDoc(userStatusFirestoreRef, isOnlineForFirestore);
                        }
                    }, { onlyOnce: true });

                    inactivityTimer = setTimeout(() => {
                        set(userStatusDatabaseRef, isAwayForDatabase);
                        updateDoc(userStatusFirestoreRef, isAwayForFirestore);
                    }, 150000); // 2.5 minutes
                };

                window.addEventListener('mousemove', resetTimer, { passive: true });
                window.addEventListener('mousedown', resetTimer, { passive: true });
                window.addEventListener('keypress', resetTimer, { passive: true });
                window.addEventListener('scroll', resetTimer, { passive: true });
                window.addEventListener('touchstart', resetTimer, { passive: true });
                
                resetTimer();
            });
        };


        onAuthStateChanged(auth, async (user) => {
            if (isRegistering) { return; }

            if (user) {
                currentUser = user; 
                if (unsubscribeUserListener) unsubscribeUserListener();
                const userDocRef = doc(db, `users/${user.uid}`);
                
                setupPresenceSystem(user.uid);

                unsubscribeUserListener = onSnapshot(userDocRef, async (docSnap) => {
                    if (docSnap.exists()) {
                        currentUserProfile = { id: docSnap.id, ...docSnap.data() };
                        
                        const unreadChats = currentUserProfile.unreadChats || [];
                        const badge = document.getElementById('chat-notification-badge');
                        if (badge) {
                            if (unreadChats.length > 0) {
                                badge.classList.remove('hidden');
                                if (unreadChats.length > previousUnreadCount) {
                                    showNotificationSound();
                                }
                            } else {
                                badge.classList.add('hidden');
                            }
                        }
                        previousUnreadCount = unreadChats.length;

                        if (currentUserProfile.banned) {
                            await renderBannedScreen();
                        } else if (!user.emailVerified && !currentUserProfile.isManuallyVerified) {
                            renderVerificationScreen();
                        } else {
                            updateUIForLoggedInUser();
                        }
                    } else {
                        if (currentUserProfile) {
                            console.error("User document was deleted. Logging out.");
                            handleLogout();
                        }
                    }
                });
            } else {
                currentUser = null;
                currentUserProfile = null; 
                if (unsubscribeUserListener) unsubscribeUserListener();
                updateUIForLoggedOutUser();
            }
        });

        const updateUIForLoggedInUser = () => {
            const crownIcon = currentUserProfile.role === 'founder' || currentUserProfile.role === 'admin' ? `<i data-lucide="crown" class="w-5 h-5 text-yellow-400"></i>` : '';
            headerTitle.innerHTML = `<span class="flex items-center gap-2">Willkommen, ${currentUserProfile.displayName} ${crownIcon}</span>`;
            headerActions.innerHTML = `
                <button id="chat-button" class="relative text-gray-300 hover:text-white">
                    <i data-lucide="message-square"></i>
                    <span id="chat-notification-badge" class="hidden absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full border-2 border-slate-800"></span>
                </button>
                <div class="relative">
                    <button id="profile-button-logged-in" class="w-10 h-10 rounded-full bg-slate-700 flex items-center justify-center hover:bg-slate-600">
                        <img src="${currentUserProfile.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${currentUserProfile.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                    </button>
                    <div id="user-dropdown-logged-in" class="hidden absolute right-0 mt-2 w-56 glass-card shadow-lg z-[51] p-2 rounded-xl">
                        <a href="#" id="settings-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="settings" class="w-4 h-4"></i> Einstellungen</a>
                        <a href="#" id="upload-video-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="video" class="w-4 h-4"></i> Video hochladen</a>
                        <a href="#" id="change-pic-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="camera" class="w-4 h-4"></i> Profilbild ändern</a>
                        <a href="#" id="notes-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="notebook" class="w-4 h-4"></i> Meine Notizen</a>
                        ${currentUserProfile.role !== 'user' ? `<a href="#" id="admin-panel-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="shield" class="w-4 h-4"></i> Admin Panel</a>` : ''}
                        <div class="border-t border-slate-700 my-1"></div>
                        <a href="#" id="logout-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white rounded-md"><i data-lucide="log-out" class="w-4 h-4"></i> Abmelden</a>
                    </div>
                </div>`;
            document.getElementById('profile-button-logged-in').addEventListener('click', () => document.getElementById('user-dropdown-logged-in').classList.toggle('hidden'));
            document.getElementById('chat-button').addEventListener('click', openChatsAndFriendsModal);
            document.getElementById('logout-btn').addEventListener('click', handleLogout);
            document.getElementById('settings-btn').addEventListener('click', showSettingsModal);
            document.getElementById('upload-video-btn').addEventListener('click', showUploadVideoModal);
            document.getElementById('change-pic-btn').addEventListener('click', showProfilePicModal);
            document.getElementById('notes-btn').addEventListener('click', showNotesModal);
            if (document.getElementById('admin-panel-btn')) {
                document.getElementById('admin-panel-btn').addEventListener('click', showAdminPanel);
            }
            lucide.createIcons();
            renderVideoFeedView();
        };

        const updateUIForLoggedOutUser = () => {
            headerTitle.textContent = 'Fortnite Status';
            headerActions.innerHTML = `<button id="profile-button-logged-out" class="w-10 h-10 rounded-full bg-slate-700 flex items-center justify-center hover:bg-slate-600"><i data-lucide="user" class="w-6 h-6 text-gray-400"></i></button>`;
            document.getElementById('profile-button-logged-out').addEventListener('click', () => showAuthModal('login'));
            lucide.createIcons();
            renderLoggedOutView();
        };
        
        const renderLoggedOutView = () => {
            mainContent.innerHTML = `
            <div class="w-full max-w-2xl space-y-6 mx-auto">
                <div class="glass-card p-6 flex justify-between items-center">
                    <div>
                        <h2 class="text-xl font-bold">Epic Games-Dienststatus</h2>
                        <p class="text-gray-400">All Systems Operational</p>
                    </div>
                    <div class="flex items-center gap-2 text-green-400">
                        <i data-lucide="check-circle-2"></i>
                        <span>Alle Systeme operationell</span>
                    </div>
                </div>
                <div class="glass-card p-6">
                    <h2 class="text-xl font-bold">Willkommen!</h2>
                    <p class="text-gray-400 mt-2">Dies ist deine zentrale Anlaufstelle für den Fortnite-Status. Melde dich an, um Videos anzusehen und die Chat-Funktionen zu nutzen!</p>
                </div>
            </div>`;
            lucide.createIcons();
        };

        const renderVerificationScreen = () => {
            headerTitle.textContent = 'E-Mail Bestätigung';
            headerActions.innerHTML = `<button id="logout-btn" class="btn-secondary">Abmelden</button>`;
            document.getElementById('logout-btn').addEventListener('click', handleLogout);

            mainContent.innerHTML = `
            <div class="w-full max-w-2xl space-y-6 mx-auto text-center">
                <div class="glass-card p-8">
                    <i data-lucide="mail-check" class="w-16 h-16 mx-auto text-blue-400 mb-4"></i>
                    <h2 class="text-2xl font-bold">Bestätige deine E-Mail-Adresse</h2>
                    <p class="text-gray-400 mt-2 mb-6">Wir haben eine Bestätigungs-E-Mail an <strong>${auth.currentUser.email}</strong> gesendet. Bitte klicke auf den Link in der E-Mail, um dein Konto zu aktivieren. Überprüfe auch deinen Spam-Ordner.</p>
                    <div class="flex flex-col sm:flex-row gap-4 justify-center">
                        <button id="resend-verification-btn" class="btn-primary">E-Mail erneut senden</button>
                        <button id="check-verification-btn" class="btn-secondary">Ich habe verifiziert, weiter</button>
                    </div>
                </div>
            </div>`;
            lucide.createIcons();

            document.getElementById('resend-verification-btn').addEventListener('click', async () => {
                try {
                    await sendEmailVerification(auth.currentUser);
                    showToast("Bestätigungs-E-Mail wurde erneut gesendet.", "success");
                } catch (error) {
                    console.error("Error resending verification email:", error);
                    showToast("Fehler beim Senden der E-Mail.", "error");
                }
            });
            document.getElementById('check-verification-btn').addEventListener('click', async () => {
                await auth.currentUser.reload();
            });
        };
        
        const renderBannedScreen = async () => {
            headerTitle.textContent = 'Konto gesperrt';
            headerActions.innerHTML = `<button id="logout-btn" class="btn-secondary">Abmelden</button>`;
            document.getElementById('logout-btn').addEventListener('click', handleLogout);
            
            let bannerName = 'einem Administrator';
            if (currentUserProfile.bannedBy) {
                const bannerDoc = await getDoc(doc(db, 'users', currentUserProfile.bannedBy));
                if (bannerDoc.exists()) {
                    bannerName = bannerDoc.data().displayName;
                }
            }
            
            mainContent.innerHTML = `
            <div class="w-full max-w-2xl space-y-6 mx-auto text-center">
                <div class="glass-card p-8">
                    <i data-lucide="gavel" class="w-16 h-16 mx-auto text-red-500 mb-4"></i>
                    <h2 class="text-2xl font-bold">Dein Konto wurde gesperrt</h2>
                    <p class="text-gray-400 mt-2">Du wurdest von <strong>${bannerName}</strong> gesperrt. Du hast keinen Zugriff auf die App-Funktionen.</p>
                </div>
            </div>`;
            lucide.createIcons();
        };

        const showAuthModal = (view = 'login') => {
            const authContent = document.getElementById('auth-content');
            const authTitle = document.getElementById('auth-title');
            if (view === 'login') {
                authTitle.textContent = 'Anmelden';
                authContent.innerHTML = `
                    <form id="login-form">
                        <input type="email" id="login-email" placeholder="E-Mail" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <input type="password" id="login-password" placeholder="Passwort" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <button type="submit" class="btn-primary w-full">Anmelden</button>
                    </form>
                    <div class="text-center mt-4 text-sm">
                        <a href="#" id="show-reset" class="text-blue-400 hover:underline">Passwort vergessen?</a>
                    </div>
                    <p class="text-center mt-2 text-sm text-gray-400">
                        Noch kein Konto? <a href="#" id="show-register" class="text-blue-400 hover:underline">Registrieren</a>
                    </p>`;
                document.getElementById('show-register').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('register'); });
                document.getElementById('show-reset').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('reset'); });
                document.getElementById('login-form').addEventListener('submit', handleLogin);
            } else if (view === 'register') {
                authTitle.textContent = 'Registrieren';
                authContent.innerHTML = `
                    <form id="register-form">
                        <input type="text" id="register-displayname" placeholder="Anzeigename" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <input type="email" id="register-email" placeholder="E-Mail" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <input type="password" id="register-password" placeholder="Passwort" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-6" required>
                        <button type="submit" class="btn-primary w-full">Konto erstellen</button>
                    </form>
                    <p class="text-center mt-4 text-sm text-gray-400">Bereits ein Konto? <a href="#" id="show-login" class="text-blue-400 hover:underline">Anmelden</a></p>`;
                document.getElementById('show-login').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('login'); });
                document.getElementById('register-form').addEventListener('submit', handleRegister);
            } else if (view === 'reset') {
                 authTitle.textContent = 'Passwort zurücksetzen';
                authContent.innerHTML = `
                    <form id="reset-form">
                        <p class="text-gray-400 mb-4">Gib deine E-Mail-Adresse ein, um einen Link zum Zurücksetzen deines Passworts zu erhalten.</p>
                        <input type="email" id="reset-email" placeholder="E-Mail" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <button type="submit" class="btn-primary w-full">Link anfordern</button>
                    </form>
                    <p class="text-center mt-4 text-sm"><a href="#" id="back-to-login" class="text-blue-400 hover:underline">Zurück zum Login</a></p>`;
                document.getElementById('back-to-login').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('login'); });
                document.getElementById('reset-form').addEventListener('submit', handlePasswordReset);
            }
            openModal(authModal);
        };

        const handleLogin = async (e) => {
            e.preventDefault();
            showLoader('Anmelden...');
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                closeModal(authModal);
            } catch (error) {
                if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential') {
                    showToast('Für diese E-Mail-Adresse wurde kein Konto gefunden.', 'error');
                } else if (error.code === 'auth/wrong-password') {
                    showToast('Falsches Passwort. Bitte versuche es erneut.', 'error');
                } else {
                    showToast(`Fehler bei der Anmeldung: ${error.message}`, 'error');
                }
            } finally {
                hideLoader();
            }
        };
        const handleRegister = async (e) => {
            e.preventDefault();
            showLoader('Konto wird erstellt...');
            const displayName = document.getElementById('register-displayname').value;
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            if (displayName.length < 3) { showToast('Anzeigename muss mindestens 3 Zeichen lang sein.', 'error'); hideLoader(); return; }
            
            isRegistering = true;
            let tempUser = null; 

            try {
                const metadataRef = doc(db, `app-metadata/${appId}`);
                const metadataSnap = await getDoc(metadataRef);
                let role = 'user';
                let isFounder = false;
                if (!metadataSnap.exists() || !metadataSnap.data().founderId) {
                    role = 'founder';
                    isFounder = true;
                }
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                tempUser = userCredential.user; 

                await updateProfile(tempUser, { displayName });
                const userDocRef = doc(db, `users/${tempUser.uid}`);
                await setDoc(userDocRef, { 
                    uid: tempUser.uid, 
                    displayName, 
                    email, 
                    role, 
                    createdAt: serverTimestamp(), 
                    photoURL: '', 
                    friends: [], 
                    banned: false, 
                    banCount: 0, 
                    bannedBy: null,
                    unreadChats: [],
                    isManuallyVerified: false
                });
                
                if (isFounder) {
                    await setDoc(metadataRef, { founderId: tempUser.uid });
                }
                
                await sendEmailVerification(tempUser);
                showToast('Registrierung erfolgreich! Bitte überprüfe dein Postfach (auch Spam) zur Verifizierung.', 'success');
                closeModal(authModal);
            } catch (error) {
                if (tempUser) {
                    await deleteUser(tempUser).catch(delErr => console.error("Failed to delete temporary user:", delErr));
                }
                if (error.code === 'auth/email-already-in-use') {
                    showToast('Diese E-Mail-Adresse wird bereits verwendet.', 'error');
                } else {
                    console.error("Registration error:", error);
                    showToast(`Fehler bei der Registrierung: ${error.message}`, 'error');
                }
            } finally {
                isRegistering = false;
                if (auth.currentUser && auth.currentUser.uid === tempUser?.uid && !auth.currentUser.emailVerified) {
                    await signOut(auth);
                }
                hideLoader();
            }
        };

        const handlePasswordReset = async (e) => {
            e.preventDefault();
            const email = document.getElementById('reset-email').value;
            if (!email) {
                showToast("Bitte gib eine E-Mail-Adresse ein.", "error");
                return;
            }
            showLoader("Sende E-Mail...");
            try {
                await sendPasswordResetEmail(auth, email);
                showToast("E-Mail zum Zurücksetzen des Passworts wurde gesendet. Bitte überprüfe dein Postfach.", "success");
                showAuthModal('login');
            } catch (error) {
                console.error("Password reset error:", error);
                showToast("Fehler beim Senden der E-Mail.", "error");
            } finally {
                hideLoader();
            }
        };

        // --- VIDEO FEED & PLAYER ---
        const renderVideoFeedView = () => {
            mainContent.innerHTML = `
                <div class="w-full max-w-7xl mx-auto">
                    <div class="glass-card p-4 mb-6 flex justify-between items-center max-w-2xl mx-auto">
                        <h2 class="text-lg font-bold">Epic Games-Dienststatus</h2>
                        <div class="flex items-center gap-2 text-green-400">
                            <i data-lucide="check-circle-2"></i>
                            <span>Alle Systeme operationell</span>
                        </div>
                    </div>
                    <div id="video-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div>
                </div>`;
            lucide.createIcons();
            
            const videosQuery = query(collection(db, "videos"));
            onSnapshot(videosQuery, (snapshot) => {
                const videoGrid = document.getElementById('video-grid');
                if (!videoGrid) return;
                videoGrid.innerHTML = '';
                if (snapshot.empty) { 
                    videoGrid.innerHTML = `<p class="col-span-full text-center text-gray-400">Noch keine Videos vorhanden. Lade das erste hoch!</p>`; 
                    return;
                }
                
                const videos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                videos.sort((a, b) => {
                    const timeA = a.createdAt?.toMillis() || 0;
                    const timeB = b.createdAt?.toMillis() || 0;
                    return timeB - timeA;
                });

                videos.forEach(video => {
                    const card = document.createElement('div');
                    card.className = 'glass-card rounded-lg overflow-hidden group';
                    
                    const canDelete = currentUserProfile.role === 'admin' || currentUserProfile.role === 'founder' || video.uploaderId === currentUser.uid;

                    card.innerHTML = `
                        <div class="relative">
                            <img src="${video.thumbnailUrl}" alt="${video.title}" class="w-full h-48 object-cover transition-transform duration-300 group-hover:scale-105 cursor-pointer">
                            <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded-md flex items-center gap-1">
                                <i data-lucide="eye" class="w-4 h-4"></i>
                                <span>${video.views || 0}</span>
                            </div>
                            ${canDelete ? `<button data-video-id="${video.id}" class="delete-video-btn absolute top-2 right-2 bg-red-600/70 hover:bg-red-500 p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"><i data-lucide="trash-2" class="w-4 h-4"></i></button>` : ''}
                        </div>
                        <div class="p-4">
                            <h3 class="font-bold text-white truncate">${video.title}</h3>
                            <p class="text-sm text-gray-400">${video.uploaderName}</p>
                        </div>`;
                    card.querySelector('img').addEventListener('click', () => openVideoPlayer(video.id));
                    if(canDelete) {
                        card.querySelector('.delete-video-btn').addEventListener('click', (e) => {
                            e.stopPropagation();
                            showConfirmationModal(`Möchtest du das Video "${video.title}" wirklich löschen?`, () => deleteVideo(video.id));
                        });
                    }
                    videoGrid.appendChild(card);
                });
                lucide.createIcons();
            });
        };

        const openVideoPlayer = async (videoId) => {
            const videoRef = doc(db, "videos", videoId);
            await updateDoc(videoRef, { views: increment(1) });
            const videoSnap = await getDoc(videoRef);
            if (!videoSnap.exists()) { showToast("Video nicht gefunden.", "error"); return; }
            const video = { id: videoSnap.id, ...videoSnap.data() };
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = video.title;
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `
                <video controls autoplay class="w-full rounded-lg bg-black max-h-[60vh]"><source src="${video.videoUrl}" type="video/mp4"></video>
                <div class="mt-4 flex justify-between items-center">
                    <p class="text-gray-400">Hochgeladen von ${video.uploaderName}</p>
                    <div class="flex items-center gap-4">
                        <button id="like-video-btn" class="flex items-center gap-2 btn-secondary"><i data-lucide="heart"></i><span id="like-count">${video.likes?.length || 0}</span></button>
                        <button id="report-video-btn" class="flex items-center gap-2 btn-secondary bg-yellow-600/50 hover:bg-yellow-500/50 text-yellow-300"><i data-lucide="flag"></i><span>Melden</span></button>
                    </div>
                </div>
                <div class="mt-4 border-t border-slate-700 pt-4"><h4 class="font-semibold mb-2 text-lg">Kommentare</h4><div id="video-comments" class="space-y-3 max-h-40 overflow-y-auto"></div></div>`;
            modalFooter.innerHTML = `<form id="add-comment-form" class="flex gap-2"><input id="comment-input" class="flex-grow p-2 bg-slate-800 border border-slate-700 rounded-lg" placeholder="Kommentar hinzufügen..." autocomplete="off"><button type="submit" class="btn-primary">Senden</button></form>`;
            openModal(genericModal);
            updateLikeButton(videoId);
            renderComments(videoId);
            document.getElementById('like-video-btn').addEventListener('click', () => toggleLike(videoId));
            document.getElementById('report-video-btn').addEventListener('click', () => showReportModal(videoId, 'video'));
            document.getElementById('add-comment-form').addEventListener('submit', (e) => { e.preventDefault(); const input = document.getElementById('comment-input'); addComment(videoId, input.value); input.value = ''; });
            lucide.createIcons();
        };

        const deleteVideo = async (videoId) => {
            showLoader("Lösche Video...");
            try {
                const videoRef = doc(db, "videos", videoId);
                const videoSnap = await getDoc(videoRef);
                if (!videoSnap.exists()) {
                    throw new Error("Video document not found.");
                }
                const videoData = videoSnap.data();

                const videoFileRef = storageRef(storage, videoData.videoUrl);
                const thumbFileRef = storageRef(storage, videoData.thumbnailUrl);
                await deleteObject(videoFileRef);
                await deleteObject(thumbFileRef);

                const commentsQuery = query(collection(db, `videos/${videoId}/comments`));
                const commentsSnapshot = await getDocs(commentsQuery);
                const batch = writeBatch(db);
                commentsSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();

                await deleteDoc(videoRef);

                showToast("Video erfolgreich gelöscht.", "success");
                closeModal(genericModal);
            } catch (error) {
                console.error("Error deleting video:", error);
                showToast("Fehler beim Löschen des Videos.", "error");
            } finally {
                hideLoader();
            }
        };

        const updateLikeButton = async (videoId) => {
            const likeBtn = document.getElementById('like-video-btn');
            if(!likeBtn) return;
            const likeIcon = likeBtn.querySelector('i');
            const likeCount = document.getElementById('like-count');
            if (!currentUser) return;
            const videoRef = doc(db, "videos", videoId);
            const videoSnap = await getDoc(videoRef);
            if (videoSnap.exists()) {
                const likes = videoSnap.data().likes || [];
                likeCount.textContent = likes.length;
                if (likes.includes(currentUser.uid)) { likeIcon.classList.add('fill-current', 'text-red-500'); } else { likeIcon.classList.remove('fill-current', 'text-red-500'); }
            }
        };

        const toggleLike = async (videoId) => {
            if (!currentUser) { showToast("Bitte anmelden, um zu liken.", "info"); return; }
            const videoRef = doc(db, "videos", videoId);
            const videoSnap = await getDoc(videoRef);
            if(videoSnap.exists()){
                const likes = videoSnap.data().likes || [];
                if(likes.includes(currentUser.uid)){ await updateDoc(videoRef, { likes: arrayRemove(currentUser.uid) }); } else { await updateDoc(videoRef, { likes: arrayUnion(currentUser.uid) }); }
                updateLikeButton(videoId);
            }
        };

        const renderComments = (videoId) => {
            const container = document.getElementById('video-comments');
            if(!container) return;
            const q = query(collection(db, `videos/${videoId}/comments`), orderBy('createdAt', 'asc'));
            onSnapshot(q, (snapshot) => {
                container.innerHTML = '';
                if(snapshot.empty){ container.innerHTML = '<p class="text-gray-500">Noch keine Kommentare.</p>'; return; }
                snapshot.forEach(doc => {
                    const comment = doc.data();
                    const commentEl = document.createElement('div');
                    commentEl.className = 'text-sm bg-slate-800/50 p-3 rounded-lg';
                    commentEl.innerHTML = `<p><span class="font-bold text-blue-300">${comment.authorName}:</span> ${comment.text}</p>`;
                    container.appendChild(commentEl);
                });
            });
        };

        const addComment = async (videoId, text) => {
            if (!text.trim()) return;
            await addDoc(collection(db, `videos/${videoId}/comments`), { text, authorId: currentUser.uid, authorName: currentUserProfile.displayName, createdAt: serverTimestamp() });
        };

        const showUploadVideoModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Video hochladen';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <div class="space-y-4">
                    <div><label class="block text-sm font-medium text-gray-300 mb-1">Video-Titel</label><input type="text" id="video-title-input" placeholder="Mein cooler Clip" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg" required></div>
                    <div><label class="block text-sm font-medium text-gray-300 mb-1">Vorschaubild</label><input type="file" id="thumbnail-upload-input" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-500" accept="image/*" required></div>
                    <div><label class="block text-sm font-medium text-gray-300 mb-1">Videodatei</label><input type="file" id="video-upload-input" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-500" accept="video/mp4,video/quicktime" required></div>
                </div>`;
            modalFooter.innerHTML = `<button id="submit-video-upload" class="btn-primary w-full">Hochladen</button>`;
            openModal(genericModal);
            document.getElementById('submit-video-upload').addEventListener('click', async () => {
                if (!currentUser) {
                    showToast("Sie müssen angemeldet sein, um ein Video hochzuladen.", "error");
                    return;
                }
                const title = document.getElementById('video-title-input').value;
                const thumbnailFile = document.getElementById('thumbnail-upload-input').files[0];
                const videoFile = document.getElementById('video-upload-input').files[0];
                if (!title || !thumbnailFile || !videoFile) { showToast("Bitte alle Felder ausfüllen.", "error"); return; }
                
                modalContent.innerHTML = `
                    <div id="upload-progress-container">
                        <p id="upload-status-text" class="text-center mb-2">Lade Vorschaubild hoch...</p>
                        <div class="w-full bg-slate-700 rounded-full h-4"><div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div></div>
                        <p id="progress-percentage" class="text-center text-sm mt-1">0%</p>
                        <p id="time-remaining" class="text-center text-xs text-gray-400 mt-1"></p>
                    </div>`;
                modalFooter.innerHTML = '';

                const uploadFile = (file, storagePath, statusText) => {
                    return new Promise((resolve, reject) => {
                        const fileRef = storageRef(storage, storagePath);
                        const metadata = { contentType: file.type };
                        const uploadTask = uploadBytesResumable(fileRef, file, metadata);
                        const uploadStartTime = Date.now();
                        const statusEl = document.getElementById('upload-status-text');
                        if (statusEl) statusEl.textContent = statusText;

                        uploadTask.on('state_changed', 
                            (snapshot) => {
                                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                                const progressBar = document.getElementById('progress-bar');
                                const progressPercentage = document.getElementById('progress-percentage');
                                const timeRemainingEl = document.getElementById('time-remaining');

                                if(progressBar) progressBar.style.width = progress + '%';
                                if(progressPercentage) progressPercentage.textContent = Math.round(progress) + '%';
                                
                                const elapsedTime = (Date.now() - uploadStartTime) / 1000;
                                if (elapsedTime > 0.5 && snapshot.bytesTransferred > 0) {
                                    const uploadSpeed = snapshot.bytesTransferred / elapsedTime;
                                    const bytesRemaining = snapshot.totalBytes - snapshot.bytesTransferred;
                                    const secondsRemaining = Math.round(bytesRemaining / uploadSpeed);
                                    if (timeRemainingEl && isFinite(secondsRemaining) && secondsRemaining > 0) {
                                        timeRemainingEl.textContent = `Verbleibende Zeit: ca. ${secondsRemaining} Sekunden`;
                                    } else if(timeRemainingEl) {
                                        timeRemainingEl.textContent = 'Berechne...';
                                    }
                                }
                            }, 
                            (error) => { 
                                console.error("Upload failed:", error);
                                const progressContainer = document.getElementById('upload-progress-container');
                                if (progressContainer) {
                                    let errorMessage = "Fehler beim Hochladen.";
                                    switch (error.code) {
                                        case 'storage/unauthorized':
                                            errorMessage = "Berechtigungsfehler. Stelle sicher, dass du angemeldet bist und die Firebase Storage Regeln den Upload erlauben.";
                                            break;
                                        case 'storage/canceled':
                                            errorMessage = "Upload abgebrochen.";
                                            break;
                                        default:
                                            errorMessage = `Ein unbekannter Fehler ist aufgetreten: ${error.code}`;
                                    }
                                    progressContainer.innerHTML = `<p class="text-red-400 text-center p-4">${errorMessage}</p>`;
                                }
                                reject(error);
                            }, 
                            async () => {
                                const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                                resolve(downloadURL);
                            }
                        );
                    });
                };

                try {
                    await auth.currentUser.getIdToken(true);
                    const thumbPath = `thumbnails/${Date.now()}_${thumbnailFile.name}`;
                    const thumbnailUrl = await uploadFile(thumbnailFile, thumbPath, 'Lade Vorschaubild hoch...');
                    
                    const videoPath = `videos/${Date.now()}_${videoFile.name}`;
                    const videoUrl = await uploadFile(videoFile, videoPath, 'Lade Video hoch...');
                    
                    const statusEl = document.getElementById('upload-status-text');
                    if (statusEl) statusEl.textContent = 'Verarbeite Daten...';
                    await addDoc(collection(db, "videos"), { title, thumbnailUrl, videoUrl, uploaderId: currentUser.uid, uploaderName: currentUserProfile.displayName, views: 0, likes: [], createdAt: serverTimestamp() });
                    
                    showToast("Video erfolgreich hochgeladen!", "success");
                    closeModal(genericModal);
                } catch (error) {
                    if (error.code) { 
                         console.error("Video upload process failed:", error);
                         showToast(`Fehler: ${error.message || 'Der Prozess konnte nicht abgeschlossen werden.'}`, "error");
                         closeModal(genericModal);
                    }
                }
            });
        };

        // --- CHATS & FRIENDS MODAL ---
        const openChatsAndFriendsModal = async () => {
            if (currentUser) {
                try {
                    const userRef = doc(db, 'users', currentUser.uid);
                    await updateDoc(userRef, { unreadChats: [] });
                } catch (error) {
                    console.error("Error clearing unread chats:", error);
                }
            }
            
            openModal(chatsFriendsModal);
            renderChatsTab();
            chatsFriendsModal.querySelectorAll('.tab-btn').forEach(btn => {
                btn.onclick = (e) => {
                    chatsFriendsModal.querySelectorAll('.tab-btn').forEach(b => { b.classList.remove('text-white', 'border-blue-500'); b.classList.add('text-gray-400', 'border-transparent'); });
                    e.currentTarget.classList.add('text-white', 'border-blue-500'); e.currentTarget.classList.remove('text-gray-400', 'border-transparent');
                    if (e.currentTarget.dataset.tab === 'chats') renderChatsTab(); else renderFriendsTab();
                };
            });
        };
        
        const renderChatsTab = async () => {
            const contentArea = document.getElementById('chats-friends-content');
            contentArea.innerHTML = `<div class="flex justify-end mb-4"><button id="create-group-btn" class="btn-primary text-sm">Neue Gruppe erstellen</button></div><div id="chats-list" class="space-y-2"></div>`;
            document.getElementById('create-group-btn').addEventListener('click', showCreateGroupModal);
            
            const list = document.getElementById('chats-list');
            list.innerHTML = `<div class="loader mx-auto"></div>`;

            const allChats = new Map();
            
            if (currentUserProfile.role === 'founder') {
                const allGroupsQuery = query(collection(db, 'groups'), where('isDeleted', '==', false));
                const groupSnaps = await getDocs(allGroupsQuery);
                groupSnaps.forEach(doc => allChats.set(doc.id, { type: 'group', id: doc.id, ...doc.data() }));
            } else {
                const memberGroupsQuery = query(collection(db, 'groups'), where('members', 'array-contains', currentUser.uid), where('isDeleted', '==', false));
                const publicGroupsQuery = query(collection(db, 'groups'), where('isPublic', '==', true), where('isDeleted', '==', false));
                const [memberGroupsSnap, publicGroupsSnap] = await Promise.all([
                    getDocs(memberGroupsQuery),
                    getDocs(publicGroupsQuery)
                ]);
                memberGroupsSnap.forEach(doc => allChats.set(doc.id, { type: 'group', id: doc.id, ...doc.data() }));
                publicGroupsSnap.forEach(doc => {
                    if (!allChats.has(doc.id)) {
                        allChats.set(doc.id, { type: 'group', id: doc.id, ...doc.data() });
                    }
                });
            }
            
            const dmsQuery = query(collection(db, 'directMessages'), where('members', 'array-contains', currentUser.uid));
            const dmsSnap = await getDocs(dmsQuery);
            
            for (const dmDoc of dmsSnap.docs) {
                const chatData = dmDoc.data();
                const friendId = chatData.members.find(id => id !== currentUser.uid);
                if (friendId) {
                    const friendDoc = await getDoc(doc(db, 'users', friendId));
                    if (friendDoc.exists()) {
                        allChats.set(dmDoc.id, { type: 'direct', id: dmDoc.id, friendId, name: friendDoc.data().displayName, photoURL: friendDoc.data().photoURL, ...chatData });
                    }
                }
            }

            if (allChats.size === 0) { list.innerHTML = `<p class="text-center text-gray-500 mt-8">Keine Chats vorhanden.</p>`; return; }
            
            list.innerHTML = '';
            allChats.forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = 'p-3 glass-card rounded-lg flex items-center justify-between gap-3';
                if (chat.type === 'group') {
                    const isMember = chat.members.includes(currentUser.uid);
                    const publicIcon = chat.isPublic ? `<i data-lucide="globe-2" class="w-4 h-4 text-cyan-400" title="Öffentliche Gruppe"></i>` : '';
                    const founderEyeIcon = currentUserProfile.role === 'founder' && !isMember ? `<i data-lucide="eye" class="w-4 h-4 text-purple-400" title="Sichtbar als Gründer"></i>` : '';
                    chatItem.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden flex-grow cursor-pointer" onclick="this.parentElement.querySelector('.join-btn, .open-btn')?.click()">
                            <div class="w-12 h-12 bg-slate-700 rounded-full flex-shrink-0 flex items-center justify-center"><i data-lucide="users"></i></div>
                            <div class="flex-grow overflow-hidden">
                                <p class="font-bold truncate flex items-center gap-2">${chat.name} ${publicIcon} ${founderEyeIcon}</p>
                                <p class="text-sm text-gray-400">${chat.members.length} Mitglieder</p>
                            </div>
                        </div>
                        ${isMember 
                            ? `<button class="open-btn btn-secondary text-sm flex-shrink-0" data-group-id="${chat.id}" data-group-name="${chat.name}">Öffnen</button>`
                            : `<button class="join-btn btn-primary text-sm flex-shrink-0" data-group-id="${chat.id}">Beitreten</button>`
                        }`;
                } else { // Direct Message
                    chatItem.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden flex-grow cursor-pointer" onclick="this.parentElement.querySelector('button')?.click()">
                            <img src="${chat.photoURL || `https://placehold.co/48x48/1E293B/FFFFFF?text=${chat.name.charAt(0)}`}" class="w-12 h-12 rounded-full object-cover flex-shrink-0">
                            <div class="flex-grow overflow-hidden">
                                <p class="font-bold truncate">${chat.name}</p>
                                <p class="text-sm text-gray-400">Direktnachricht</p>
                            </div>
                        </div>
                        <button class="btn-secondary text-sm flex-shrink-0" data-friend-id="${chat.friendId}" data-friend-name="${chat.name}">Öffnen</button>
                        `;
                }
                list.appendChild(chatItem);
            });
            list.querySelectorAll('.open-btn[data-group-id]').forEach(btn => btn.addEventListener('click', (e) => openGroupChat(e.currentTarget.dataset.groupId)));
            list.querySelectorAll('.join-btn[data-group-id]').forEach(btn => btn.addEventListener('click', async (e) => {
                const groupId = e.currentTarget.dataset.groupId;
                await updateDoc(doc(db, 'groups', groupId), { members: arrayUnion(currentUser.uid) });
                showToast("Gruppe beigetreten!", "success");
                renderChatsTab();
            }));
            list.querySelectorAll('button[data-friend-id]').forEach(btn => btn.addEventListener('click', (e) => openDirectChat(e.currentTarget.dataset.friendId, e.currentTarget.dataset.friendName)));

            lucide.createIcons();
        };

        const renderFriendsTab = () => {
            const contentArea = document.getElementById('chats-friends-content');
            contentArea.innerHTML = `
                <div class="flex justify-end mb-4"><button id="add-friend-btn" class="btn-primary text-sm">Freund hinzufügen</button></div>
                <div id="friend-requests-container" class="mb-6"><h3 class="text-lg font-semibold mb-2">Anfragen</h3><div id="friend-requests-list" class="space-y-2"></div></div>
                <div><h3 class="text-lg font-semibold mb-2">Freundesliste</h3><div id="friends-list" class="space-y-2"></div></div>`;
            document.getElementById('add-friend-btn').addEventListener('click', showAddFriendModal);
            const userDocRef = doc(db, `users/${currentUser.uid}`);
            onSnapshot(userDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const userData = docSnap.data();
                    displayFriendRequests(userData.friendRequestsReceived || []);
                    displayFriends(userData.friends || []);
                }
            });
        };

        const showAddFriendModal = async () => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Freund hinzufügen';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<p class="text-gray-400 mb-4">Suche nach dem Anzeigenamen (optional).</p><input type="text" id="search-user-input" placeholder="Nutzer suchen..." class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg"><div id="search-results" class="mt-4 space-y-2 max-h-96 overflow-y-auto"></div>`;
            modalFooter.innerHTML = '';
            openModal(genericModal);

            try {
                const usersRef = collection(db, "users");
                const allUsersSnapshot = await getDocs(usersRef);
                const allUsers = allUsersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                const renderUserList = (usersToRender) => {
                    const resultsContainer = document.getElementById('search-results');
                    resultsContainer.innerHTML = '';
                    usersToRender.forEach((user) => {
                        if (user.id === currentUser.uid) return;
                        const isFriend = currentUserProfile.friends.includes(user.id);
                        const userCard = document.createElement('div');
                        userCard.className = 'glass-card p-3 flex items-center justify-between';
                        userCard.innerHTML = `<div class="flex items-center gap-3"><img src="${user.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover"><div><p class="font-semibold text-white">${user.displayName}</p></div></div><button data-id="${user.id}" class="add-friend-search-btn btn-secondary text-sm" ${isFriend ? 'disabled' : ''}>${isFriend ? 'Freund' : 'Hinzufügen'}</button>`;
                        resultsContainer.appendChild(userCard);
                    });
                    resultsContainer.querySelectorAll('.add-friend-search-btn').forEach(btn => {
                        btn.addEventListener('click', async () => {
                            const targetUserId = btn.dataset.id;
                            btn.disabled = true;
                            btn.textContent = 'Angefragt';
                            await sendFriendRequest(targetUserId);
                        });
                    });
                };

                renderUserList(allUsers); 

                document.getElementById('search-user-input').addEventListener('keyup', (e) => {
                    const searchTerm = e.target.value.trim().toLowerCase();
                    const filteredUsers = allUsers.filter(user => user.displayName.toLowerCase().includes(searchTerm));
                    renderUserList(filteredUsers);
                });
            } catch (error) {
                console.error("Error fetching users for friend search:", error);
                modalContent.innerHTML = `<div class="text-center p-4"><p class="text-red-400">Benutzersuche fehlgeschlagen.</p><p class="text-gray-400 mt-2 text-sm">Dies liegt wahrscheinlich an den Firestore-Sicherheitsregeln. Administratoren benötigen eine "list"-Berechtigung für die "users"-Sammlung, um alle Benutzer anzuzeigen.</p></div>`;
            }
        };
        const sendFriendRequest = async (targetUserId) => { try { const targetUserRef = doc(db, `users/${targetUserId}`); const currentUserRef = doc(db, `users/${currentUser.uid}`); const batch = writeBatch(db); batch.update(targetUserRef, { friendRequestsReceived: arrayUnion(currentUser.uid) }); batch.update(currentUserRef, { friendRequestsSent: arrayUnion(targetUserId) }); await batch.commit(); showToast('Freundschaftsanfrage gesendet!', 'success'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } };
        const displayFriendRequests = async (requestUids) => {
            const container = document.getElementById('friend-requests-list'); if(!container) return;
            if (!requestUids || requestUids.length === 0) { container.innerHTML = `<p class="text-gray-500">Keine offenen Anfragen.</p>`; return; }
            container.innerHTML = '';
            for (const uid of requestUids) {
                const userDoc = await getDoc(doc(db, `users/${uid}`));
                if (userDoc.exists()) {
                    const user = userDoc.data();
                    const requestCard = document.createElement('div');
                    requestCard.className = 'glass-card p-3 flex items-center justify-between';
                    requestCard.innerHTML = `<div class="flex items-center gap-3"><img src="${user.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover"><p class="font-semibold text-white">${user.displayName}</p></div><div class="flex gap-2"><button data-id="${uid}" class="accept-friend-btn btn-primary text-sm">Annehmen</button><button data-id="${uid}" class="decline-friend-btn btn-secondary text-sm">Ablehnen</button></div>`;
                    container.appendChild(requestCard);
                }
            }
            container.querySelectorAll('.accept-friend-btn').forEach(btn => btn.addEventListener('click', () => acceptFriendRequest(btn.dataset.id)));
            container.querySelectorAll('.decline-friend-btn').forEach(btn => btn.addEventListener('click', () => declineFriendRequest(btn.dataset.id)));
        };
        const acceptFriendRequest = async (senderId) => { try { const batch = writeBatch(db); const currentUserRef = doc(db, `users/${currentUser.uid}`); const senderUserRef = doc(db, `users/${senderId}`); batch.update(currentUserRef, { friends: arrayUnion(senderId), friendRequestsReceived: arrayRemove(senderId) }); batch.update(senderUserRef, { friends: arrayUnion(currentUser.uid), friendRequestsSent: arrayRemove(currentUser.uid) }); await batch.commit(); showToast('Freund hinzugefügt!', 'success'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } };
        const declineFriendRequest = async (senderId) => { try { const batch = writeBatch(db); const currentUserRef = doc(db, `users/${currentUser.uid}`); const senderUserRef = doc(db, `users/${senderId}`); batch.update(currentUserRef, { friendRequestsReceived: arrayRemove(senderId) }); batch.update(senderUserRef, { friendRequestsSent: arrayRemove(currentUser.uid) }); await batch.commit(); showToast('Anfrage abgelehnt.', 'info'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } };
        const displayFriends = async (friendUids) => {
            const container = document.getElementById('friends-list'); if(!container) return;
            if (!friendUids || friendUids.length === 0) { container.innerHTML = `<p class="text-gray-500">Du hast noch keine Freunde.</p>`; return; }
            container.innerHTML = '';
            for (const uid of friendUids) {
                const userDoc = await getDoc(doc(db, `users/${uid}`));
                if (userDoc.exists()) {
                    const user = {id: userDoc.id, ...userDoc.data()};
                    const friendCard = document.createElement('div');
                    friendCard.className = 'glass-card p-3 flex items-center justify-between';
                    
                    let statusIcon = '';
                    if (user.presence === 'online') {
                        statusIcon = `<i data-lucide="circle" class="w-3 h-3 text-green-500 fill-current"></i>`;
                    } else if (user.presence === 'away') {
                        statusIcon = `<i data-lucide="moon" class="w-3 h-3 text-yellow-400 fill-current"></i>`;
                    }

                    friendCard.innerHTML = `<div class="flex items-center gap-3">
                        <div class="relative">
                            <img src="${user.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                            <div class="absolute -bottom-1 -right-1" id="status-icon-${user.id}">${statusIcon}</div>
                        </div>
                        <p class="font-semibold text-white">${user.displayName}</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button data-id="${user.id}" data-name="${user.displayName}" class="call-friend-btn text-green-400 hover:text-green-300"><i data-lucide="phone"></i></button>
                        <button data-id="${user.id}" data-name="${user.displayName}" class="chat-friend-btn text-blue-400 hover:text-blue-300"><i data-lucide="message-circle"></i></button>
                        <button data-id="${user.id}" data-name="${user.displayName}" class="report-user-btn text-yellow-400 hover:text-yellow-300"><i data-lucide="flag"></i></button>
                        <button data-id="${user.id}" class="remove-friend-btn text-red-500 hover:text-red-400"><i data-lucide="user-minus"></i></button>
                    </div>`;
                    container.appendChild(friendCard);
                }
            }
            lucide.createIcons();
            container.querySelectorAll('.remove-friend-btn').forEach(btn => { btn.addEventListener('click', () => removeFriend(btn.dataset.id)); });
            container.querySelectorAll('.chat-friend-btn').forEach(btn => { btn.addEventListener('click', () => openDirectChat(btn.dataset.id, btn.dataset.name)); });
            container.querySelectorAll('.call-friend-btn').forEach(btn => { btn.addEventListener('click', () => showCallingModal(btn.dataset.name)); });
            container.querySelectorAll('.report-user-btn').forEach(btn => { btn.addEventListener('click', () => showReportModal(btn.dataset.id, 'user', { userName: btn.dataset.name })); });
        };
        const removeFriend = async (friendId) => { showConfirmationModal('Bist du sicher, dass du diesen Freund entfernen möchtest?', async () => { try { const batch = writeBatch(db); const currentUserRef = doc(db, `users/${currentUser.uid}`); const friendUserRef = doc(db, `users/${friendId}`); batch.update(currentUserRef, { friends: arrayRemove(friendId) }); batch.update(friendUserRef, { friends: arrayRemove(currentUser.uid) }); await batch.commit(); showToast('Freund entfernt.', 'info'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } }); };
        
        const showCreateGroupModal = () => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Neue Gruppe erstellen';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<form id="create-group-form"><input type="text" id="group-name" placeholder="Gruppenname" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required><textarea id="group-desc" placeholder="Beschreibung" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required></textarea></form>`;
            modalFooter.innerHTML = `<button id="submit-create-group" class="btn-primary w-full">Erstellen</button>`;
            openModal(genericModal);
            document.getElementById('submit-create-group').addEventListener('click', async () => {
                const name = document.getElementById('group-name').value;
                const description = document.getElementById('group-desc').value;
                if (!name || !description) { showToast('Bitte fülle alle Felder aus.', 'error'); return; }
                showLoader('Gruppe wird erstellt...');
                try { 
                    await addDoc(collection(db, 'groups'), { 
                        name, 
                        description, 
                        ownerId: currentUser.uid, 
                        members: [currentUser.uid], 
                        createdAt: serverTimestamp(), 
                        isPublic: false,
                        isDeleted: false 
                    }); 
                    showToast('Gruppe erfolgreich erstellt!', 'success'); 
                    closeModal(genericModal); 
                    renderChatsTab(); 
                } catch (error) { 
                    showToast(`Fehler: ${error.message}`, 'error'); 
                } finally { 
                    hideLoader(); 
                }
            });
        };

        const getChatRoomId = (uid1, uid2) => [uid1, uid2].sort().join('_');

        const openDirectChat = (friendId, friendName) => {
            const chatRoomId = getChatRoomId(currentUser.uid, friendId);
            openChat(chatRoomId, friendName, 'direct');
        };

        const openGroupChat = async (groupId) => {
            const groupRef = doc(db, 'groups', groupId);
            const groupSnap = await getDoc(groupRef);
            if (!groupSnap.exists()) {
                showToast("Gruppe nicht gefunden.", "error");
                return;
            }
            const groupData = { id: groupSnap.id, ...groupSnap.data() };
            openChat(groupData.id, groupData.name, 'group', groupData);
        };

        const openChat = async (chatId, chatName, type, groupData = null) => {
            closeModal(chatsFriendsModal);

            setTimeout(async () => {
                if (currentUser) {
                    const userRef = doc(db, 'users', currentUser.uid);
                    await updateDoc(userRef, { unreadChats: arrayRemove(chatId) });
                }

                activeChatId = chatId;
                activeChatType = type;
                if (unsubscribeChatListener) unsubscribeChatListener();
                if (unsubscribeTypingListener) unsubscribeTypingListener();

                const modalTitle = document.getElementById('generic-modal-title');
                const modalContent = document.getElementById('generic-modal-content');
                const modalFooter = document.getElementById('generic-modal-footer');
                const modalHeaderActions = document.getElementById('generic-modal-header-actions');

                modalTitle.textContent = chatName;
                modalContent.innerHTML = `<div id="chat-messages" class="h-96 overflow-y-auto flex flex-col-reverse p-2 space-y-2 space-y-reverse"></div>`;
                
                modalFooter.innerHTML = `
                    <div id="typing-indicator" class="text-sm text-gray-400 h-5 italic mb-1"></div>
                    <form id="chat-form" class="flex gap-2 items-center">
                        <button type="button" id="attach-image-btn" class="btn-secondary p-2"><i data-lucide="paperclip"></i></button>
                        <input type="file" id="image-upload-input" class="hidden" accept="image/*">
                        <button type="button" id="gif-btn" class="btn-secondary p-2"><i data-lucide="file-image"></i></button>
                        <button type="button" id="mic-btn" class="btn-secondary p-2"><i data-lucide="mic"></i></button>
                        <div class="relative flex-grow">
                            <input id="chat-input" class="w-full p-2 bg-slate-800 border border-slate-700 rounded-lg pr-10" placeholder="Nachricht schreiben..." autocomplete="off">
                            <button type="button" id="emoji-btn" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white"><i data-lucide="smile"></i></button>
                        </div>
                        <button type="submit" class="btn-primary p-2"><i data-lucide="send"></i></button>
                    </form>
                `;
                
                modalHeaderActions.innerHTML = '';
                if (type === 'group' && groupData) {
                    const isOwner = groupData.ownerId === currentUser.uid;
                    const isFounder = currentUserProfile.role === 'founder';
                    let dropdownHTML = `<a href="#" id="invite-friend-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="user-plus" class="w-4 h-4"></i> Freunde einladen</a>`;
                    
                    if(isOwner) {
                        dropdownHTML += `<a href="#" id="manage-members-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="users" class="w-4 h-4"></i> Mitglieder verwalten</a>`;
                    }
                    if (isFounder) {
                        dropdownHTML += `<a href="#" id="toggle-public-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="${groupData.isPublic ? 'lock' : 'globe-2'}" class="w-4 h-4"></i> ${groupData.isPublic ? 'Privat machen' : 'Öffentlich machen'}</a>`;
                    }
                    dropdownHTML += `<div class="border-t border-slate-700 my-1"></div>`;
                    dropdownHTML += isOwner 
                                    ? `<a href="#" id="delete-group-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white rounded-md"><i data-lucide="trash" class="w-4 h-4"></i> Gruppe löschen</a>`
                                    : `<a href="#" id="leave-group-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white rounded-md"><i data-lucide="log-out" class="w-4 h-4"></i> Gruppe verlassen</a>`;

                    modalHeaderActions.innerHTML = `
                        <div class="relative">
                            <button id="group-settings-btn" class="text-gray-300 hover:text-white"><i data-lucide="settings-2"></i></button>
                            <div id="group-settings-dropdown" class="hidden absolute right-0 mt-2 w-56 glass-card shadow-lg z-[51] p-2 rounded-xl">
                                ${dropdownHTML}
                            </div>
                        </div>`;

                    document.getElementById('group-settings-btn').addEventListener('click', () => document.getElementById('group-settings-dropdown').classList.toggle('hidden'));
                    document.getElementById('invite-friend-btn').addEventListener('click', () => showInviteFriendsModal(chatId, groupData.members));
                    if (isOwner) {
                        document.getElementById('manage-members-btn').addEventListener('click', () => showGroupMembersModal(chatId, groupData.ownerId));
                    }
                    if (isFounder) {
                        document.getElementById('toggle-public-btn').addEventListener('click', () => toggleGroupPublicStatus(chatId, groupData.isPublic));
                    }
                    if (isOwner) {
                        document.getElementById('delete-group-btn').addEventListener('click', () => deleteGroup(chatId, chatName));
                    } else {
                        document.getElementById('leave-group-btn').addEventListener('click', () => leaveGroup(chatId, chatName));
                    }
                }

                lucide.createIcons();
                openModal(genericModal);
                
                document.getElementById('attach-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
                document.getElementById('image-upload-input').addEventListener('change', handleImageUpload);
                document.getElementById('emoji-btn').addEventListener('click', () => togglePicker('emoji'));
                document.getElementById('gif-btn').addEventListener('click', () => togglePicker('gif'));
                document.getElementById('mic-btn').addEventListener('click', handleRecordButtonClick);

                const collectionPath = type === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
                const chatRoomRef = doc(db, type === 'group' ? 'groups' : 'directMessages', chatId);

                try {
                    await setDoc(chatRoomRef, { 
                        ...(type === 'direct' && { members: chatId.split('_') }),
                        typing: {}
                    }, { merge: true });
                } catch (e) {
                    console.error("Error ensuring chat document exists:", e);
                    showToast("Konnte den Chat nicht öffnen.", "error");
                    closeModal(genericModal);
                    return;
                }

                const messagesContainer = document.getElementById('chat-messages');
                const messagesQuery = query(collection(db, collectionPath), orderBy('timestamp', 'desc'));
                unsubscribeChatListener = onSnapshot(messagesQuery, (snapshot) => {
                    messagesContainer.innerHTML = '';
                    snapshot.forEach(docSnap => {
                        const msg = {id: docSnap.id, ...docSnap.data()};
                        const messageEl = document.createElement('div');
                        const isSender = msg.senderId === currentUser.uid;
                        const isGroupOwner = type === 'group' && groupData && groupData.ownerId === currentUser.uid;
                        
                        messageEl.className = `w-full flex group ${isSender ? 'justify-end' : 'justify-start'}`;
                        
                        let readReceipt = '';
                        if (isSender && !msg.isDeleted) {
                            if (msg.readBy && msg.readBy.length > 1) {
                                readReceipt = `<i data-lucide="check-check" class="w-4 h-4 text-blue-400"></i>`;
                            } else {
                                readReceipt = `<i data-lucide="check" class="w-4 h-4 text-gray-500"></i>`;
                            }
                        }

                        const canDelete = (isSender || isGroupOwner) && !msg.isDeleted;
                        
                        let messageContentHTML = '';
                        if (msg.isDeleted) {
                            messageContentHTML = `<p class="text-gray-500 italic">Diese Nachricht wurde gelöscht.</p>`;
                        } else if (msg.type === 'gif' || msg.type === 'image') {
                            messageContentHTML = `<a href="${msg.content}" target="_blank" rel="noopener noreferrer"><img src="${msg.content}" alt="Gesendetes Bild" class="rounded-lg max-w-xs h-auto mt-1 cursor-pointer hover:opacity-80"></a>`;
                        } else if (msg.type === 'audio') {
                            messageContentHTML = `<audio controls src="${msg.content}" class="max-w-full"></audio>`;
                        } else { 
                            const linkedText = linkify(msg.text || '');
                            messageContentHTML = `<p class="text-white break-words">${linkedText}</p>`;
                        }
                        
                        const timestampHTML = !msg.isDeleted ? `
                            <div class="flex items-center justify-end gap-1 mt-1">
                                <p class="text-xs text-gray-400">${new Date(msg.timestamp?.toDate()).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</p>
                                ${readReceipt}
                            </div>` : '';

                        const senderNameHTML = !isSender && type === 'group' && !msg.isDeleted
                            ? `<p class="text-xs font-bold text-blue-300">${msg.senderName}</p>`
                            : '';
                        
                        const messageBoxClass = isSender 
                            ? (msg.type === 'gif' || msg.type === 'image' ? 'bg-transparent' : 'bg-blue-700')
                            : (msg.isDeleted ? 'bg-slate-800/50' : (msg.type === 'gif' || msg.type === 'image' ? 'bg-transparent' : 'bg-slate-700'));

                        messageEl.innerHTML = `
                            <div class="flex items-end gap-2 ${isSender ? 'flex-row-reverse' : 'flex-row'}">
                                <div class="max-w-xs lg:max-w-md px-3 py-2 rounded-lg ${messageBoxClass}">
                                    ${senderNameHTML}
                                    ${messageContentHTML}
                                    ${timestampHTML}
                                </div>
                            </div>
                        `;
                        
                        if (canDelete) {
                            const messageBox = messageEl.querySelector('.max-w-xs');
                            const handlePressStart = (e) => {
                                const targetElement = e.currentTarget;
                                clearTimeout(longPressTimer);
                                longPressTimer = setTimeout(() => {
                                    showMessageContextMenu(targetElement, chatId, msg.id, type, msg.senderId);
                                }, 500);
                            };
                            const handlePressEnd = () => clearTimeout(longPressTimer);

                            messageBox.addEventListener('mousedown', handlePressStart);
                            messageBox.addEventListener('mouseup', handlePressEnd);
                            messageBox.addEventListener('mouseleave', handlePressEnd);
                            messageBox.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                handlePressStart(e);
                            });
                            messageBox.addEventListener('touchend', handlePressEnd);
                        }

                        messagesContainer.appendChild(messageEl);

                        if (!isSender && !msg.isDeleted && (!msg.readBy || !msg.readBy.includes(currentUser.uid))) {
                            updateDoc(docSnap.ref, { readBy: arrayUnion(currentUser.uid) });
                        }
                    });

                    lucide.createIcons();
                });

                const typingIndicator = document.getElementById('typing-indicator');
                unsubscribeTypingListener = onSnapshot(chatRoomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const typingUsers = docSnap.data().typing || {};
                        const otherTypers = Object.keys(typingUsers).filter(uid => uid !== currentUser.uid && typingUsers[uid]);
                        if (otherTypers.length > 0) {
                            typingIndicator.textContent = '... schreibt';
                        } else {
                            typingIndicator.textContent = '';
                        }
                    }
                });

                const chatInput = document.getElementById('chat-input');
                chatInput.addEventListener('input', () => {
                    clearTimeout(typingTimeout);
                    updateDoc(chatRoomRef, { [`typing.${currentUser.uid}`]: true });
                    typingTimeout = setTimeout(() => {
                        updateDoc(chatRoomRef, { [`typing.${currentUser.uid}`]: false });
                    }, 2000);
                });

                document.getElementById('chat-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    clearTimeout(typingTimeout);
                    updateDoc(chatRoomRef, { [`typing.${currentUser.uid}`]: false });
                    const text = chatInput.value.trim();
                    if (text) {
                        chatInput.value = '';
                        try {
                            await addDoc(collection(db, collectionPath), { 
                                text, 
                                type: 'text',
                                senderId: currentUser.uid, 
                                senderName: currentUserProfile.displayName, 
                                timestamp: serverTimestamp(), 
                                readBy: [currentUser.uid] 
                            });

                            const chatDocSnap = await getDoc(chatRoomRef);
                            if (chatDocSnap.exists()) {
                                const members = chatDocSnap.data().members;
                                const batch = writeBatch(db);
                                members.forEach(memberId => {
                                    if (memberId !== currentUser.uid) {
                                        const userRef = doc(db, 'users', memberId);
                                        batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                                    }
                                });
                                await batch.commit();
                            }

                        } catch (error) {
                            console.error("Error sending message:", error);
                            showToast("Nachricht konnte nicht gesendet werden.", "error");
                        }
                    }
                });
            }, 300);
        };
        
        // --- Chat Management Functions ---
        const showMessageContextMenu = (targetElement, chatId, messageId, type, senderId) => {
            const menu = document.getElementById('message-context-menu');
            const deleteBtn = document.getElementById('delete-context-btn');
            const reportBtn = document.getElementById('report-context-btn');
            
            const rect = targetElement.getBoundingClientRect();
            menu.style.top = `${rect.top - menu.offsetHeight - 5}px`;
            menu.style.left = `${rect.left}px`;
            menu.classList.remove('hidden');

            const hideMenu = () => {
                menu.classList.add('hidden');
                document.removeEventListener('click', hideMenuOnClickOutside);
            }
            
            const hideMenuOnClickOutside = (event) => {
                if (!menu.contains(event.target)) {
                    hideMenu();
                }
            };
            
            deleteBtn.onclick = () => {
                hideMenu();
                showConfirmationModal('Möchtest du diese Nachricht wirklich löschen?', () => {
                    deleteMessage(chatId, messageId, type);
                });
            };
            
            if (senderId === currentUser.uid) {
                reportBtn.classList.add('hidden');
            } else {
                reportBtn.classList.remove('hidden');
                reportBtn.onclick = () => {
                    hideMenu();
                    showReportModal(messageId, 'message', { chatId, chatType: type, senderId });
                };
            }

            setTimeout(() => document.addEventListener('click', hideMenuOnClickOutside), 0);
        };

        const deleteMessage = async (chatId, messageId, type) => {
            const collectionPath = type === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            const messageRef = doc(db, collectionPath, messageId);
            try {
                await updateDoc(messageRef, {
                    text: "Diese Nachricht wurde gelöscht.",
                    content: null,
                    type: 'text',
                    isDeleted: true
                });
            } catch (error) {
                console.error("Error 'deleting' message:", error);
                showToast("Nachricht konnte nicht gelöscht werden.", "error");
            }
        };
        
        const leaveGroup = async (groupId, groupName) => {
            showConfirmationModal(`Möchtest du die Gruppe "${groupName}" wirklich verlassen?`, async () => {
                showLoader("Verlasse Gruppe...");
                try {
                    const groupRef = doc(db, 'groups', groupId);
                    await updateDoc(groupRef, { members: arrayRemove(currentUser.uid) });
                    showToast(`Gruppe "${groupName}" verlassen.`, "success");
                    closeModal(genericModal);
                    renderChatsTab();
                } catch (error) {
                    showToast("Fehler beim Verlassen der Gruppe.", "error");
                } finally {
                    hideLoader();
                }
            });
        };

        const deleteGroup = async (groupId, groupName) => {
            showConfirmationModal(`Möchtest du die Gruppe "${groupName}" wirklich löschen?`, async () => {
                showLoader("Lösche Gruppe...");
                try {
                    const groupRef = doc(db, 'groups', groupId);
                    await updateDoc(groupRef, {
                        isDeleted: true,
                        members: []
                    });
                    showToast(`Gruppe "${groupName}" wurde gelöscht.`, "success");
                    closeModal(genericModal);
                    renderChatsTab();
                } catch (error) {
                    console.error("Error deleting group:", error);
                    showToast("Fehler beim Löschen der Gruppe.", "error");
                } finally {
                    hideLoader();
                }
            });
        };
        
        const toggleGroupPublicStatus = async (groupId, isCurrentlyPublic) => {
            const newStatus = !isCurrentlyPublic;
            showLoader("Aktualisiere Status...");
            try {
                await updateDoc(doc(db, 'groups', groupId), { isPublic: newStatus });
                showToast(`Gruppe ist nun ${newStatus ? 'öffentlich' : 'privat'}.`, "success");
                closeModal(genericModal); 
                openGroupChat(groupId);
            } catch (error) {
                showToast("Status konnte nicht geändert werden.", "error");
            } finally {
                hideLoader();
            }
        };

        const showInviteFriendsModal = async (groupId, currentMembers) => {
            document.getElementById('group-settings-dropdown')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = 'Freunde einladen';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `<div id="invite-list" class="space-y-2 max-h-96 overflow-y-auto"></div>`;
            modalFooter.innerHTML = `<button id="close-invite-modal" class="btn-secondary w-full">Fertig</button>`;

            const friends = currentUserProfile.friends || [];
            if (friends.length === 0) {
                modalContent.innerHTML = `<p class="text-gray-500">Du hast keine Freunde zum Einladen.</p>`;
            } else {
                const inviteList = document.getElementById('invite-list');
                inviteList.innerHTML = '';
                for(const friendId of friends) {
                    const userDoc = await getDoc(doc(db, `users/${friendId}`));
                    if (userDoc.exists()) {
                        const friendData = userDoc.data();
                        const isAlreadyMember = currentMembers.includes(friendId);
                        const card = document.createElement('div');
                        card.className = 'glass-card p-3 flex items-center justify-between';
                        card.innerHTML = `
                            <div class="flex items-center gap-3">
                                <img src="${friendData.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${friendData.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                                <p class="font-semibold text-white">${friendData.displayName}</p>
                            </div>
                            <button data-friend-id="${friendId}" class="invite-friend-btn btn-primary text-sm" ${isAlreadyMember ? 'disabled' : ''}>
                                ${isAlreadyMember ? 'Mitglied' : 'Einladen'}
                            </button>
                        `;
                        inviteList.appendChild(card);
                    }
                }
                inviteList.querySelectorAll('.invite-friend-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const friendId = btn.dataset.friendId;
                        await updateDoc(doc(db, 'groups', groupId), { members: arrayUnion(friendId) });
                        showToast("Freund eingeladen!", "success");
                        btn.textContent = 'Mitglied';
                        btn.disabled = true;
                    });
                });
            }

            document.getElementById('close-invite-modal').onclick = async () => {
                closeModal(genericModal);
                await openGroupChat(groupId);
            };
        };

        const showGroupMembersModal = async (groupId, ownerId) => {
            document.getElementById('group-settings-dropdown')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = 'Mitglieder verwalten';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `<div id="member-list" class="space-y-2 max-h-96 overflow-y-auto"></div>`;
            modalFooter.innerHTML = `<button id="close-members-modal" class="btn-secondary w-full">Schließen</button>`;
            
            const groupDoc = await getDoc(doc(db, 'groups', groupId));
            if (!groupDoc.exists()) return;

            const members = groupDoc.data().members || [];
            const list = document.getElementById('member-list');
            list.innerHTML = '';

            for(const memberId of members) {
                const userDoc = await getDoc(doc(db, 'users', memberId));
                if (userDoc.exists()) {
                    const memberData = userDoc.data();
                    const card = document.createElement('div');
                    card.className = 'glass-card p-3 flex items-center justify-between';
                    let removeButton = '';
                    let reportButton = '';
                    if (memberId !== currentUser.uid) {
                        reportButton = `<button data-id="${memberId}" data-name="${memberData.displayName}" class="report-user-btn text-yellow-400 hover:text-yellow-300 p-1"><i data-lucide="flag"></i></button>`;
                    }
                    if (currentUser.uid === ownerId && memberId !== ownerId) {
                        removeButton = `<button data-member-id="${memberId}" data-member-name="${memberData.displayName}" class="remove-member-btn btn-primary bg-red-600 hover:bg-red-500 text-sm">Entfernen</button>`;
                    }
                    card.innerHTML = `
                        <div class="flex items-center gap-3">
                            <img src="${memberData.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${memberData.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                            <p class="font-semibold text-white">${memberData.displayName}</p>
                        </div>
                        <div class="flex items-center gap-2">
                            ${reportButton}
                            ${removeButton}
                        </div>
                    `;
                    list.appendChild(card);
                }
            }
            lucide.createIcons();
            list.querySelectorAll('.remove-member-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const memberId = btn.dataset.memberId;
                    const memberName = btn.dataset.memberName;
                    showConfirmationModal(`Möchtest du ${memberName} wirklich aus der Gruppe entfernen?`, async () => {
                        await updateDoc(doc(db, 'groups', groupId), { members: arrayRemove(memberId) });
                        showToast(`${memberName} wurde entfernt.`, "success");
                        showGroupMembersModal(groupId, ownerId); // Refresh the list
                    });
                });
            });
            list.querySelectorAll('.report-user-btn').forEach(btn => {
                btn.addEventListener('click', () => showReportModal(btn.dataset.id, 'user', { userName: btn.dataset.name }));
            });

            document.getElementById('close-members-modal').onclick = async () => {
                closeModal(genericModal);
                await openGroupChat(groupId);
            };
        };

        
        const showCallingModal = (friendName) => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = `Rufe ${friendName} an`;
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<div class="text-center p-8"><div class="loader mx-auto"></div><p class="mt-4">Verbinde...</p><p class="text-xs text-gray-500 mt-2">(Anruf-Funktion ist derzeit eine Simulation)</p></div>`;
            modalFooter.innerHTML = `<button id="end-call-btn" class="btn-primary bg-red-600 hover:bg-red-500 w-full">Anruf beenden</button>`;
            openModal(genericModal);
            document.getElementById('end-call-btn').onclick = () => closeModal(genericModal);
        };
        
        const showProfilePicModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Profilbild ändern';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<div class="flex flex-col items-center"><img id="pic-preview" src="${currentUserProfile.photoURL || `https://placehold.co/128x128/1E293B/FFFFFF?text=${currentUserProfile.displayName.charAt(0)}`}" class="w-32 h-32 rounded-full object-cover mb-4 border-2 border-slate-600"><input type="file" id="pic-upload-input" class="hidden" accept="image/*"><label for="pic-upload-input" class="btn-secondary cursor-pointer">Bild auswählen</label></div>`;
            modalFooter.innerHTML = `<button id="submit-pic-upload" class="btn-primary w-full" disabled>Hochladen & Speichern</button>`;
            openModal(genericModal);
            const input = document.getElementById('pic-upload-input');
            const preview = document.getElementById('pic-preview');
            const submitBtn = document.getElementById('submit-pic-upload');
            let selectedFile = null;
            input.addEventListener('change', (e) => {
                selectedFile = e.target.files[0];
                if (selectedFile) {
                    const reader = new FileReader();
                    reader.onload = (event) => { preview.src = event.target.result; };
                    reader.readAsDataURL(selectedFile);
                    submitBtn.disabled = false;
                }
            });
            submitBtn.addEventListener('click', async () => {
                if (!selectedFile) return;
                if (!currentUser) {
                    showToast("Sie müssen angemeldet sein, um ein Bild hochzuladen.", "error");
                    return;
                }
                
                modalContent.innerHTML = `
                    <div id="upload-progress-container">
                        <p id="upload-status-text" class="text-center mb-2">Lade Profilbild hoch...</p>
                        <div class="w-full bg-slate-700 rounded-full h-4"><div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div></div>
                        <p id="progress-percentage" class="text-center text-sm mt-1">0%</p>
                    </div>`;
                modalFooter.innerHTML = '';
                
                try {
                    await auth.currentUser.getIdToken(true);
                    const fileRef = storageRef(storage, `profilePictures/${currentUser.uid}`);
                    const metadata = { contentType: selectedFile.type };
                    const uploadTask = uploadBytesResumable(fileRef, selectedFile, metadata);

                    uploadTask.on('state_changed', 
                        (snapshot) => {
                            const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                            const progressBar = document.getElementById('progress-bar');
                            const progressPercentage = document.getElementById('progress-percentage');
                            if (progressBar) progressBar.style.width = progress + '%';
                            if (progressPercentage) progressPercentage.textContent = Math.round(progress) + '%';
                        }, 
                        (error) => {
                            console.error("Upload failed", error);
                            const progressContainer = document.getElementById('upload-progress-container');
                            if (progressContainer) {
                                let errorMessage = "Fehler beim Hochladen.";
                                if (error.code === 'storage/unauthorized') {
                                    errorMessage = "Berechtigungsfehler. Bitte erneut anmelden und sicherstellen, dass die Storage-Regeln korrekt sind.";
                                }
                                progressContainer.innerHTML = `<p class="text-red-400 text-center p-4">${errorMessage}</p>`;
                            }
                        }, 
                        async () => {
                            try {
                                const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                                await updateDoc(doc(db, 'users', currentUser.uid), { photoURL: downloadURL });
                                await updateProfile(auth.currentUser, { photoURL: downloadURL });
                                showToast('Profilbild erfolgreich aktualisiert!', 'success');
                                closeModal(genericModal);
                            } catch (e) {
                                console.error("Error updating profile:", e);
                                showToast('Fehler beim Aktualisieren des Profils.', 'error');
                                closeModal(genericModal);
                            }
                        }
                    );
                } catch(error) {
                    console.error("Token refresh or upload failed:", error);
                    showToast('Authentifizierung fehlgeschlagen oder Upload-Fehler.', 'error');
                    closeModal(genericModal);
                }
            });
        };
        
        const showNotesModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Meine Notizen';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<div id="notes-list" class="space-y-2"></div>`;
            modalFooter.innerHTML = `<form id="add-note-form" class="flex gap-2"><input id="note-input" class="flex-grow p-2 bg-slate-800 border border-slate-700 rounded-lg" placeholder="Neue Notiz..." autocomplete="off"><button type="submit" class="btn-primary"><i data-lucide="plus"></i></button></form>`;
            lucide.createIcons();
            openModal(genericModal);
            const notesCollectionRef = collection(db, `users/${currentUser.uid}/notes`);
            const q = query(notesCollectionRef, orderBy('createdAt', 'desc'));
            onSnapshot(q, (snapshot) => {
                const list = document.getElementById('notes-list');
                if (!list) return;
                list.innerHTML = '';
                if(snapshot.empty) { list.innerHTML = `<p class="text-center text-gray-500 p-4">Keine Notizen vorhanden.</p>`; return; }
                snapshot.forEach(doc => {
                    const note = { id: doc.id, ...doc.data() };
                    const noteEl = document.createElement('div');
                    noteEl.className = 'p-3 glass-card rounded-lg flex justify-between items-center';
                    noteEl.innerHTML = `<p>${note.text}</p><button data-id="${note.id}" class="delete-note-btn text-red-500 hover:text-red-400"><i data-lucide="trash-2"></i></button>`;
                    list.appendChild(noteEl);
                });
                list.querySelectorAll('.delete-note-btn').forEach(btn => { btn.addEventListener('click', () => { const noteId = btn.dataset.id; deleteDoc(doc(db, `users/${currentUser.uid}/notes`, noteId)); }); });
                lucide.createIcons();
            });
            document.getElementById('add-note-form').addEventListener('submit', async (e) => { e.preventDefault(); const input = document.getElementById('note-input'); const text = input.value.trim(); if (text) { input.value = ''; await addDoc(notesCollectionRef, { text, createdAt: serverTimestamp() }); } });
        };

        const showSettingsModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Einstellungen';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <div class="space-y-4">
                    <button id="change-name-btn" class="w-full text-left p-3 glass-card hover:bg-slate-700 rounded-lg">Anzeigename ändern</button>
                    <button id="change-password-btn" class="w-full text-left p-3 glass-card hover:bg-slate-700 rounded-lg">Passwort ändern</button>
                    <div class="flex justify-between items-center p-3 glass-card rounded-lg">
                        <label for="notifications-toggle">Benachrichtigungston</label>
                        <input type="checkbox" id="notifications-toggle" class="toggle-checkbox">
                    </div>
                </div>
            `;
            modalFooter.innerHTML = '';
            openModal(genericModal);

            document.getElementById('change-name-btn').addEventListener('click', showChangeNameModal);
            document.getElementById('change-password-btn').addEventListener('click', showChangePasswordModal);
            
            const notifToggle = document.getElementById('notifications-toggle');
            notifToggle.checked = currentUserProfile.notificationsEnabled || false;
            notifToggle.addEventListener('change', toggleNotifications);
        };

        const showChangeNameModal = () => {
            closeModal(genericModal);
            setTimeout(() => { // Allow old modal to close
                const modalTitle = document.getElementById('generic-modal-title');
                const modalContent = document.getElementById('generic-modal-content');
                const modalFooter = document.getElementById('generic-modal-footer');
                modalTitle.textContent = 'Anzeigename ändern';
                modalContent.innerHTML = `
                    <div>
                        <label for="change-displayname-input" class="block text-sm font-medium text-gray-300 mb-1">Neuer Anzeigename</label>
                        <input type="text" id="change-displayname-input" value="${currentUserProfile.displayName}" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg">
                    </div>
                `;
                modalFooter.innerHTML = `<button id="save-settings-btn" class="btn-primary">Änderungen speichern</button>`;
                openModal(genericModal);

                document.getElementById('save-settings-btn').onclick = async () => {
                    const newName = document.getElementById('change-displayname-input').value.trim();
                    if (newName.length < 3) {
                        showToast("Der Anzeigename muss mindestens 3 Zeichen lang sein.", "error");
                        return;
                    }
                    if (newName === currentUserProfile.displayName) {
                        closeModal(genericModal);
                        return;
                    }
                    showLoader("Speichere...");
                    try {
                        await updateProfile(auth.currentUser, { displayName: newName });
                        await updateDoc(doc(db, 'users', currentUser.uid), { displayName: newName });
                        showToast("Anzeigename erfolgreich geändert!", "success");
                        closeModal(genericModal);
                    } catch (error) {
                        console.error("Error updating display name:", error);
                        showToast("Fehler beim Ändern des Namens.", "error");
                    } finally {
                        hideLoader();
                    }
                };
            }, 350);
        };

        const showChangePasswordModal = () => {
            closeModal(genericModal);
            setTimeout(() => {
                const modalTitle = document.getElementById('generic-modal-title');
                const modalContent = document.getElementById('generic-modal-content');
                const modalFooter = document.getElementById('generic-modal-footer');
                modalTitle.textContent = 'Passwort ändern';
                modalContent.innerHTML = `<p class="text-gray-300">Wir senden dir eine E-Mail an <strong>${currentUser.email}</strong>, mit der du dein Passwort zurücksetzen kannst.</p>`;
                modalFooter.innerHTML = `<button id="send-password-reset-btn" class="btn-primary">E-Mail senden</button>`;
                openModal(genericModal);

                document.getElementById('send-password-reset-btn').onclick = async () => {
                    showLoader("Sende E-Mail...");
                    try {
                        await sendPasswordResetEmail(auth, currentUser.email);
                        showToast("E-Mail zum Zurücksetzen des Passworts wurde gesendet. Bitte überprüfe dein Postfach.", "success");
                        closeModal(genericModal);
                    } catch (error) {
                        console.error("Password reset error:", error);
                        showToast("Fehler beim Senden der E-Mail.", "error");
                    } finally {
                        hideLoader();
                    }
                };
            }, 350);
        };
        
        const toggleNotifications = async (e) => {
            const enabled = e.target.checked;
            try {
                await updateDoc(doc(db, 'users', currentUser.uid), { notificationsEnabled: enabled });
                if (enabled) {
                    showToast("Benachrichtigungstöne aktiviert!", "success");
                } else {
                    showToast("Benachrichtigungstöne deaktiviert.", "info");
                }
            } catch (error) {
                showToast("Fehler beim Speichern der Einstellung.", "error");
            }
        };

        const showNotificationSound = () => {
            if (!currentUserProfile.notificationsEnabled) return;
            
            if (!notificationSound) {
                notificationSound = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
                }).toDestination();
            }
            notificationSound.triggerAttackRelease("C5", "8n");
        };
        
        // --- EMOJI, GIF & AUDIO FUNCTIONS ---

        const togglePicker = (type) => {
            if (activePicker === type) {
                hidePicker();
            } else {
                activePicker = type;
                pickerPopover.innerHTML = '';
                pickerPopover.classList.remove('hidden');

                if (type === 'emoji') {
                    renderEmojiPicker();
                } else if (type === 'gif') {
                    renderGifPicker();
                }
            }
        };

        const hidePicker = () => {
            if (!pickerPopover.classList.contains('hidden')) {
                pickerPopover.classList.add('hidden');
                activePicker = null;
            }
        };

        const renderEmojiPicker = () => {
            const emojiPicker = document.createElement('emoji-picker');
            emojiPicker.className = 'w-full h-80';
            pickerPopover.appendChild(emojiPicker);
            emojiPicker.addEventListener('emoji-click', e => {
                const chatInput = document.getElementById('chat-input');
                chatInput.value += e.detail.unicode;
            });
        };
        
        const renderGifPicker = () => {
            pickerPopover.innerHTML = `
                <div class="p-2">
                    <input id="gif-search-input" type="text" placeholder="GIPHY durchsuchen..." class="w-full p-2 bg-slate-800 border border-slate-700 rounded-lg mb-2">
                    <div id="gif-results" class="grid grid-cols-3 gap-2 h-72 overflow-y-auto">
                        <div class="col-span-3 text-center text-gray-400 pt-8">Suche nach GIFs...</div>
                    </div>
                </div>
            `;
            const searchInput = document.getElementById('gif-search-input');
            let searchTimeout;
            searchInput.addEventListener('keyup', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    searchGifs(searchInput.value);
                }, 500);
            });
            searchGifs('');
        };

        const searchGifs = async (query) => {
            const resultsContainer = document.getElementById('gif-results');
            if (!resultsContainer) return;

            if (GIPHY_API_KEY === 'DEIN_GIPHY_API_SCHLÜSSEL') {
                resultsContainer.innerHTML = `<div class="col-span-3 text-center text-red-400 p-4">Bitte füge einen gültigen Giphy API-Schlüssel im Skript hinzu, um GIFs zu suchen.</div>`;
                return;
            }

            resultsContainer.innerHTML = `<div class="col-span-3 flex justify-center pt-8"><div class="loader"></div></div>`;
            
            const endpoint = query ? `search?q=${encodeURIComponent(query)}` : 'trending?';
            const url = `https://api.giphy.com/v1/gifs/${endpoint}&api_key=${GIPHY_API_KEY}&limit=30`;

            try {
                const response = await fetch(url);
                const json = await response.json();
                resultsContainer.innerHTML = '';
                if (json.data && json.data.length > 0) {
                    json.data.forEach(gif => {
                        const img = document.createElement('img');
                        img.src = gif.images.fixed_height_small.url;
                        img.alt = gif.title;
                        img.className = 'w-full h-full object-cover rounded-md cursor-pointer hover:opacity-80';
                        img.onclick = () => sendGifMessage(gif.images.original.url, activeChatId);
                        resultsContainer.appendChild(img);
                    });
                } else {
                    resultsContainer.innerHTML = `<div class="col-span-3 text-center text-gray-400 pt-8">Keine Ergebnisse gefunden.</div>`;
                }
            } catch (error) {
                console.error("Error fetching GIFs:", error);
                resultsContainer.innerHTML = `<div class="col-span-3 text-center text-red-400 p-4">Fehler beim Laden der GIFs.</div>`;
            }
        };

        const sendGifMessage = async (gifUrl, chatId) => {
            if (!chatId || !activeChatType) return;
            const collectionPath = activeChatType === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            try {
                await addDoc(collection(db, collectionPath), {
                    type: 'gif',
                    content: gifUrl,
                    text: '[GIF]',
                    senderId: currentUser.uid,
                    senderName: currentUserProfile.displayName,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid]
                });

                const chatDocRef = doc(db, activeChatType === 'group' ? 'groups' : 'directMessages', chatId);
                const chatDocSnap = await getDoc(chatDocRef);
                if (chatDocSnap.exists()) {
                    const members = chatDocSnap.data().members;
                    const batch = writeBatch(db);
                    members.forEach(memberId => {
                        if (memberId !== currentUser.uid) {
                            const userRef = doc(db, 'users', memberId);
                            batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                        }
                    });
                    await batch.commit();
                }

                hidePicker();
            } catch (error) {
                console.error("Error sending GIF message:", error);
                showToast("GIF konnte nicht gesendet werden.", "error");
            }
        };

        const handleRecordButtonClick = () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        };

        const startRecording = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true;
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const audioFileName = `audio_${Date.now()}.webm`;
                    const fileRef = storageRef(storage, `chatAudio/${activeChatId}/${audioFileName}`);
                    
                    showLoader('Lade Sprachnachricht hoch...');
                    try {
                        const uploadTask = uploadBytesResumable(fileRef, audioBlob);
                        await uploadTask;
                        const downloadURL = await getDownloadURL(fileRef);
                        await sendAudioMessage(downloadURL, activeChatId);
                    } catch (error) {
                        console.error("Error uploading audio:", error);
                        showToast("Fehler beim Hochladen der Sprachnachricht.", "error");
                    } finally {
                        hideLoader();
                    }
                };

                mediaRecorder.start();
                const micBtn = document.getElementById('mic-btn');
                if (micBtn) {
                    micBtn.classList.add('bg-red-600', 'recording-indicator');
                }
            } catch (error) {
                console.error("Error accessing microphone:", error);
                showToast("Mikrofonzugriff verweigert oder nicht verfügbar.", "error");
            }
        };

        const stopRecording = () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                const micBtn = document.getElementById('mic-btn');
                if (micBtn) {
                    micBtn.classList.remove('bg-red-600', 'recording-indicator');
                }
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        };

        const sendAudioMessage = async (audioUrl, chatId) => {
            if (!chatId || !activeChatType) return;
            const collectionPath = activeChatType === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            try {
                await addDoc(collection(db, collectionPath), {
                    type: 'audio',
                    content: audioUrl,
                    text: '[Sprachnachricht]',
                    senderId: currentUser.uid,
                    senderName: currentUserProfile.displayName,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid]
                });

                const chatDocRef = doc(db, activeChatType === 'group' ? 'groups' : 'directMessages', chatId);
                const chatDocSnap = await getDoc(chatDocRef);
                if (chatDocSnap.exists()) {
                    const members = chatDocSnap.data().members;
                    const batch = writeBatch(db);
                    members.forEach(memberId => {
                        if (memberId !== currentUser.uid) {
                            const userRef = doc(db, 'users', memberId);
                            batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                        }
                    });
                    await batch.commit();
                }
            } catch (error) {
                console.error("Error sending audio message:", error);
                showToast("Sprachnachricht konnte nicht gesendet werden.", "error");
            }
        };

        const handleImageUpload = async (event) => {
            const file = event.target.files[0];
            if (!file || !activeChatId) return;

            showLoader("Lade Bild hoch...");
            try {
                await auth.currentUser.getIdToken(true);
                const fileRef = storageRef(storage, `chatImages/${activeChatId}/${Date.now()}_${file.name}`);
                const uploadTask = uploadBytesResumable(fileRef, file, { contentType: file.type });

                uploadTask.on('state_changed',
                    (snapshot) => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        showLoader(`Lade Bild hoch... ${Math.round(progress)}%`);
                    },
                    (error) => {
                        console.error("Image upload failed:", error);
                        showToast("Bild-Upload fehlgeschlagen.", "error");
                        hideLoader();
                    },
                    async () => {
                        const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                        await sendImageMessage(downloadURL, activeChatId);
                        hideLoader();
                        showToast("Bild gesendet!", "success");
                    }
                );
            } catch (error) {
                console.error("Error during image upload process:", error);
                showToast("Fehler beim Bild-Upload.", "error");
                hideLoader();
            }
        };

        const sendImageMessage = async (imageUrl, chatId) => {
            if (!chatId || !activeChatType) return;
            const collectionPath = activeChatType === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            try {
                await addDoc(collection(db, collectionPath), {
                    type: 'image',
                    content: imageUrl,
                    text: '[Bild]',
                    senderId: currentUser.uid,
                    senderName: currentUserProfile.displayName,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid]
                });

                const chatDocRef = doc(db, activeChatType === 'group' ? 'groups' : 'directMessages', chatId);
                const chatDocSnap = await getDoc(chatDocRef);
                if (chatDocSnap.exists()) {
                    const members = chatDocSnap.data().members;
                    const batch = writeBatch(db);
                    members.forEach(memberId => {
                        if (memberId !== currentUser.uid) {
                            const userRef = doc(db, 'users', memberId);
                            batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                        }
                    });
                    await batch.commit();
                }
            } catch (error) {
                console.error("Error sending image message:", error);
                showToast("Bild konnte nicht gesendet werden.", "error");
            }
        };


        // --- INITIALIZATION ---
        window.onload = () => {
            lucide.createIcons();
            if (!app) return;
            updateUIForLoggedOutUser();
        };
        
        // --- Event Listeners for Modals ---
        document.getElementById('close-auth-modal').addEventListener('click', () => closeModal(authModal));
        document.getElementById('close-chats-friends-modal').addEventListener('click', () => closeModal(chatsFriendsModal));
        
        document.getElementById('close-generic-modal').addEventListener('click', () => {
            const wasChatOpen = activeChatId !== null;

            if (unsubscribeChatListener) {
                unsubscribeChatListener();
                unsubscribeChatListener = null;
            }
            if (unsubscribeTypingListener) {
                unsubscribeTypingListener();
                unsubscribeTypingListener = null;
            }
            hidePicker();
            
            if (wasChatOpen) {
                activeChatId = null;
                activeChatType = null;
            }

            closeModal(genericModal);

            if(wasChatOpen) {
                setTimeout(() => {
                    openChatsAndFriendsModal();
                }, 300);
            }
        });

        document.addEventListener('click', (e) => {
            if (activePicker && !pickerPopover.contains(e.target) && !e.target.closest('#emoji-btn') && !e.target.closest('#gif-btn')) {
                hidePicker();
            }
        });

    </script>
</body>
</html>
